//Adds bind support
if (!('bind' in Function.prototype)) {
	Function.prototype.bind = function(owner) {
		var that = this;
		var args = Array.prototype.slice.call(arguments, 1);
		return function() {
			return that.apply(owner, args.length===0? arguments : arguments.length===0? args : args.concat(Array.prototype.slice.call(arguments, 0)));
		};
	};
}

//Adds window.location.origin support
if (!window.location.origin) {
	window.location.origin = window.location.protocol + "//" + window.location.hostname + (window.location.port ? ':' + window.location.port: '');
}

(function () {

	if (!window.CustomEvent) {

		var CustomEvent = function ( event, params ) {
			params = params || { bubbles: false, cancelable: false, detail: undefined };
			var evt = document.createEvent( 'CustomEvent' );
			evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
			return evt;
		}

		CustomEvent.prototype = window.Event.prototype;

		window.CustomEvent = CustomEvent;

	}



})();


// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik MÃ¶ller. fixes from Paul Irish and Tino Zijdel
// MIT license
(function () {
	var lastTime = 0;
	var vendors = ['ms', 'moz', 'webkit', 'o'];
	for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
		window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
		window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
	}
	if(!window.requestAnimationFrame)
		window.requestAnimationFrame = function (callback, element) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function () {
					callback(currTime + timeToCall);
				},
				timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
	if(!window.cancelAnimationFrame)
		window.cancelAnimationFrame = function (id) {
			clearTimeout(id);
		};
}());





/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

window.matchMedia || (window.matchMedia = function() {
	"use strict";

	// For browsers that support matchMedium api such as IE 9 and webkit
	var styleMedia = (window.styleMedia || window.media);

	// For those that don't support matchMedium
	if (!styleMedia) {
		var style       = document.createElement('style'),
			script      = document.getElementsByTagName('script')[0],
			info        = null;

		style.type  = 'text/css';
		style.id    = 'matchmediajs-test';

		script.parentNode.insertBefore(style, script);

		// 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
		info = ('getComputedStyle' in window) && window.getComputedStyle(style, null) || style.currentStyle;

		styleMedia = {
			matchMedium: function(media) {
				var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

				// 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
				if (style.styleSheet) {
					style.styleSheet.cssText = text;
				} else {
					style.textContent = text;
				}

				// Test if media query is true or false
				return info.width === '1px';
			}
		};
	}

	return function(media) {
		return {
			matches: styleMedia.matchMedium(media || 'all'),
			media: media || 'all'
		};
	};
}());



/*! matchMedia() polyfill addListener/removeListener extension. Author & copyright (c) 2012: Scott Jehl. Dual MIT/BSD license */
(function(){
	// Bail out for browsers that have addListener support
	if (window.matchMedia && window.matchMedia('all').addListener) {
		return false;
	}

	var localMatchMedia = window.matchMedia,
		hasMediaQueries = localMatchMedia('only all').matches,
		isListening     = false,
		timeoutID       = 0,    // setTimeout for debouncing 'handleChange'
		queries         = [],   // Contains each 'mql' and associated 'listeners' if 'addListener' is used
		handleChange    = function(evt) {
			// Debounce
			clearTimeout(timeoutID);

			timeoutID = setTimeout(function() {
				for (var i = 0, il = queries.length; i < il; i++) {
					var mql         = queries[i].mql,
						listeners   = queries[i].listeners || [],
						matches     = localMatchMedia(mql.media).matches;

					// Update mql.matches value and call listeners
					// Fire listeners only if transitioning to or from matched state
					if (matches !== mql.matches) {
						mql.matches = matches;

						for (var j = 0, jl = listeners.length; j < jl; j++) {
							listeners[j].call(window, mql);
						}
					}
				}
			}, 30);
		};

	window.matchMedia = function(media) {
		var mql         = localMatchMedia(media),
			listeners   = [],
			index       = 0;

		mql.addListener = function(listener) {
			// Changes would not occur to css media type so return now (Affects IE <= 8)
			if (!hasMediaQueries) {
				return;
			}

			// Set up 'resize' listener for browsers that support CSS3 media queries (Not for IE <= 8)
			// There should only ever be 1 resize listener running for performance
			if (!isListening) {
				isListening = true;
				window.addEventListener('resize', handleChange, true);
			}

			// Push object only if it has not been pushed already
			if (index === 0) {
				index = queries.push({
					mql         : mql,
					listeners   : listeners
				});
			}

			listeners.push(listener);
		};

		mql.removeListener = function(listener) {
			for (var i = 0, il = listeners.length; i < il; i++){
				if (listeners[i] === listener){
					listeners.splice(i, 1);
				}
			}
		};

		return mql;
	};
}());

tsunami = this.tsunami || {};

(function() {

	tsunami.EventDispatcher = function() {
		this.construct();
	}

	var p = tsunami.EventDispatcher.prototype;

	p.construct = function() {
		this.listeners = [];
		this._debug = false;
	};

	p.addEventListener = function(type, func) {
		this.listeners.push({type:type, func:func});
	};

	p.removeEventListener = function(type, func) {
		var newListeners = [];
		for (var i = 0 ; i < this.listeners.length; i++) {
			var listener = this.listeners[i];
			if (listener.type == type && listener.func == func) {

			} else {
				newListeners.push(listener);
			}
		}

		this.listeners = newListeners;
	};

	p.dispatchEvent = function(event) {
		if (this._debug) {
			console.log("dispatchEvent", event.type, this);
		}
		event.target = this;
		if (!event.currentTarget) {
			event.currentTarget = this;
		}
		for (var i = 0 ; i < this.listeners.length; i++) {
			var listener = this.listeners[i];
			if (listener.type == event.type) {
				listener.func(event);
			}
		}
	};

	p.destroy = function() {
		this.listeners = [];
	};

	p.getDebug = function() {
		return this._debug;
	};

	p.setDebug = function(value) {
		this._debug = value;
	};

}());

tsunami = this.tsunami || {};
tsunami.utils = this.tsunami.utils || {};

(function() {

	tsunami.clock = new tsunami.EventDispatcher();

	tsunami.clock.time = new Date();

	tsunami.clock.tick = function() {
		tsunami.clock.time = new Date();
		tsunami.clock.dispatchEvent({type:"tick"});
	};

	tsunami.utils.isMobile = {
		android: navigator.userAgent.match(/Android/i) ? true : false,
		blackBerry: navigator.userAgent.match(/BlackBerry/i) ? true : false,
		iOS: navigator.userAgent.match(/iPhone|iPad|iPod/i) ? true : false,
		windows: navigator.userAgent.match(/IEMobile/i) ? true : false
	};

	tsunami.utils.isMobile.any = (tsunami.utils.isMobile.android || tsunami.utils.isMobile.blackBerry || tsunami.utils.isMobile.iOS || tsunami.utils.isMobile.windows);

	if (tsunami.utils.isMobile.any) {
		tsunami.events = {
			mouseover: "touchstart",
			mouseout: "touchend",
			mousedown: "touchstart",
			mouseup: "touchend",
			mousemove: "touchmove"
		}
	} else {
		tsunami.events = {
			mouseover: "mouseover",
			mouseout: "mouseout",
			mousedown: "mousedown",
			mouseup: "mouseup",
			mousemove: "mousemove"
		}
	}

	tsunami.events.COMPLETE = "complete";
	tsunami.events.CHANGE = "change";

	tsunami.utils.mustacheRender = null;

	tsunami.utils.applyWrapperAttribute = function(element, attributeName) {
		var objects = tsunami.utils.getAllObjects(element);
		for (var i = objects.length - 1; i > -1; i--) {
			var object = objects[i];
			if (tsunami.Element) {
				tsunami.Element(object);
			}
			if (object.getAttribute) {
				var attribute = object.getAttribute(attributeName);
				if (attribute) {
					var classNames = attribute.split(" ");
					for (var k = 0; k < classNames.length; k++) {
						var className = classNames[k];
						if (className) {
							var method;
							method = eval(className);
							if (method) {
								method(object);
							} else {
								throw (className + " is an undefined method.");
							}
						}
					}
				}
			}
		}
	};

	tsunami.utils.applyWrapper = function(element, method) {
		if (!method) {
			throw "tsunami.utils.applyWrapper was called with an undefined method";
		}
		var objects = tsunami.utils.getAllObjects(element);
		for (var i = objects.length - 1; i > -1; i--) {
			var object = objects[i];
			method(object);
		}
		method(element);
	};

	tsunami.utils.createElement = function(templateText, parent, wrapper, model, index) {
		if (!wrapper) {
			wrapper = "wrapper";
		}
		if (!tsunami.utils.factory) {
			tsunami.utils.factory = document.createElement("div");
		}
		if (tsunami.utils.mustacheRender) {
			templateText = tsunami.utils.mustacheRender(templateText, {model:model, index:index, window:window});
		}
		tsunami.utils.factory.innerHTML = templateText;
		var element = tsunami.utils.factory.children.item(0);
		if (parent) {
			parent.appendChild(element);
		}
		tsunami.utils.applyWrapper(element, tsunami.Element);
		tsunami.utils.applyWrapperAttribute(element, wrapper);
		if (model) {
			element.model = model;
		}
		return element;
	};

	tsunami.utils.getAllObjects = function(element, array) {
		if (!array) {
			array = [];
		}
		array.push(element);

		var children = element.childNodes;
		for (var i = 0; i < children.length; i++) {
			var child = children.item(i);
			if (child.nodeName != "#text") {
				tsunami.utils.getAllObjects(child, array);
			}
		}
		return array;
	};

	tsunami.utils.getCookie = function(cname) {
		var name = cname + "=";
		var ca = document.cookie.split(';');
		for(var i=0; i<ca.length; i++) {
			var c = ca[i];
			while (c.charAt(0)==' ') c = c.substring(1);
			if (c.indexOf(name) == 0) return c.substring(name.length, c.length);
		}
		return "";
	};

	tsunami.utils.getSearchParams = function(dontDecodeURI) {
		var urlParams = {};
		if (window.location.href.indexOf('?') != -1) {
			var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
			for(var i = 0; i < hashes.length; i++) {
				var string = hashes[i];
				var equalIndex = string.indexOf("=");
				if (equalIndex != -1) {
					var hash = [];
					//var hash = hashes[i].split('=');
					hash[0] = string.substr(0, equalIndex);
					hash[1] = string.substr(equalIndex + 1);
					if (dontDecodeURI) {
						urlParams[hash[0]] = hash[1];
					} else {
						urlParams[hash[0]] = decodeURI(hash[1]);
					}
				}
			}
		}
		return urlParams;
	};

	tsunami.utils.getWindowRect = function() {
		var rectangle = new tsunami.geom.Rectangle();
		rectangle.width =  document.documentElement.clientWidth || document.body.clientWidth || window.innerWidth;
		rectangle.height =  document.documentElement.clientHeight || document.body.clientHeight || window.innerHeight;
		return rectangle;
	};

	tsunami.utils.localToGlobal = function(element, root, point) {
		if (!point) {
			point = new tsunami.geom.Point();
		}
		while(element != root) {
			point.x += element.offsetLeft - element.parentNode.scrollLeft;
			point.y += element.offsetTop - element.parentNode.scrollTop;
			element = element.parentNode;
		}
		return point;
	};

	tsunami.utils.serialize = function(obj) {
		var str = [];
		for(var p in obj)
			if (obj.hasOwnProperty(p)) {
				str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
			}
		return str.join("&");
	};

	tsunami.utils.isHidden = function() {
		return document[tsunami.utils.hidden];
	};

	tsunami.utils.setVisibilityProps = function() {
		var prefixes = ['webkit','moz','ms','o'];

		// if 'hidden' is natively supported just return it
		if ('hidden' in document) {
			tsunami.utils.hidden = 'hidden';
			tsunami.events.visibilitychange = 'visibilitychange';
		}

		// otherwise loop over all the known prefixes until we find one
		for (var i = 0; i < prefixes.length; i++){
			if ((prefixes[i] + 'Hidden') in document) {
				tsunami.utils.hidden = prefixes[i] + 'Hidden';
				tsunami.events.visibilitychange = prefixes[i] + 'visibilitychange';
			}
		}
	};

	tsunami.utils.setVisibilityProps();

	tsunami.utils.setTransitionEndEventName = function  () {
		var i,
			undefined,
			el = document.createElement('div'),
			transitions = {
				'transition':'transitionend',
				'OTransition':'otransitionend',  // oTransitionEnd in very old Opera
				'MozTransition':'transitionend',
				'WebkitTransition':'webkitTransitionEnd'
			};

		for (i in transitions) {
			if (transitions.hasOwnProperty(i) && el.style[i] !== undefined) {
				tsunami.events.transitionEnd = transitions[i];
			}
		}
	};

	tsunami.utils.setTransitionEndEventName();

	tsunami.utils.fixURLProtocol = function(url, protocol) {
		var isHttps = (protocol.indexOf("https") != -1);
		var urlIsHttps = (url.indexOf("https") != -1);
		if (isHttps && !urlIsHttps) {
			url = url.split("http").join("https");
		} else if (!isHttps && urlIsHttps) {
			url = url.split("https").join("http");
		}
		return url;
	};


}());

tsunami = this.tsunami || {};
tsunami.geom = tsunami.geom || {};

(function() {

	tsunami.geom.Point = function(x, y) {
		this.constructor(x, y);
	};

    var c = tsunami.geom.Point;
    var p = tsunami.geom.Point.prototype;

    p.constructor = function(x, y) {
		this.x = (isNaN(x))?0:x;
		this.y = (isNaN(y))?0:y;
	};
	
	p.clone = function() {
		return new tsunami.geom.Point(this.x, this.y);
	};

	p.add = function(p) {
		var point = new tsunami.geom.Point();
		point.x = this.x + p.x;
		point.y = this.y + p.y;
		return point;
	};

	p.multiply = function(p) {
		var point = new tsunami.geom.Point();
		point.x = this.x * p.x;
		point.y = this.y * p.y;
		return point;
	};

	p.divide = function(p) {
		var point = new tsunami.geom.Point();
		point.x = this.x / p.x;
		point.y = this.y / p.y;
		return point;
	};

	p.equals = function(point) {
		return (this.x == point.x && this.y == point.y);
	};

	p.copyFrom = function(p) {
		this.x = p.x;
		this.y = p.y;
	};

	p.subtract = function(p) {
		var point = new tsunami.geom.Point();
		point.x = this.x - p.x;
		point.y = this.y - p.y;
		return point;
	};

	p.clamp = function(minX, maxX, minY, maxY) {
		this.clampX(minX, maxX);
		this.clampY(minY, maxY);
	};

	p.clampX = function(min, max) {
		this.x = Math.max(this.x, min);
		this.x = Math.min(this.x, max);
	};

	p.clampY = function(min, max) {
		this.y = Math.max(this.y, min);
		this.y = Math.min(this.y, max);
	};

	p.toString = function() {
		return "[Point" + " x=" + this.x + " y=" + this.y + "]";
	};

	c.distance = function(p1, p2) {
		return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
	};

	c.polar = function(len, radians) {
		return new tsunami.geom.Point(len * Math.cos(radians), len * Math.sin(radians));
	};
	
}());
tsunami = this.tsunami || {};
tsunami.geom = tsunami.geom || {};

(function() {

	tsunami.geom.Rectangle = function(x, y, width, height) {
		this.constructor(x, y, width, height);
	};
	
	var p = tsunami.geom.Rectangle.prototype;
	
	p.constructor = function(x, y, width, height) {
		this.x = (isNaN(x))?0:x;
		this.y = (isNaN(y))?0:y;
		this.width = (isNaN(width))?0:width;
		this.height = (isNaN(height))?0:height;
	};

    p.containsPoint = function(point) {
		var hit = (point.x >= this.x && point.x <= this.x + this.width && point.y >= this.y && point.y <= this.y + this.height)?true:false;
		return hit;
    };

	p.intersects = function(rect) {
		return rect.x + rect.width > this.x && rect.y + rect.height > this.y && rect.x < this.x + this.width && rect.y < this.y + this.height;
	};

	p.equals = function(rect) {
		return (this.x == rect.x && this.y == rect.y && this.width == rect.width && this.height == rect.height);
	};

	p.clone = function(rect) {
		return new tsunami.geom.Rectangle(this.x, this.y, this.width, this.height);
	};

	p.copyFrom = function(rect) {
		this.x = rect.x;
		this.y = rect.y;
		this.width = rect.width;
		this.height = rect.height;
	};

	p.scale = function(x, y) {
		return new tsunami.geom.Rectangle(this.x, this.y, this.width * x, this.height * y);
	};

	p.getScaleToFill = function(rect) {
		var scale;
		var thisSize = this.width / this.height;
		var rectSize = rect.width / rect.height;
		if (thisSize > rectSize) {
			scale = rect.height / this.height;
		} else {
			scale = rect.width / this.width;
		}
		return scale;
	};

	p.getScaleToFit = function(rect) {
		var scale;
		var thisSize = this.width / this.height;
		var rectSize = rect.width / rect.height;
		if (thisSize > rectSize) {
			scale = rect.width / this.width;
		} else {
			scale = rect.height / this.height;
		}
		return scale;
	};

	p.getSize = function() {
		return new tsunami.geom.Point(this.width, this.height);
	};

	p.toString = function() {
		return "[Rectangle" + " x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + "]";
	};
	
}());
tsunami = this.tsunami || {};
tsunami.geom = tsunami.geom || {};

(function() {

	tsunami.geom.Ratio = function() {
		this.constructor();
	};
	
	var c = tsunami.geom.Ratio;
	
	var p = tsunami.geom.Ratio.prototype;
	
	c.widthToHeight = function(rect) {
		return rect.width / rect.height;
	};
	
	c.heightToWidth = function(rect) {
		return rect.height / rect.width;
	};
	
	/*
	c.scale = function(rect, amount, snapToPixel) {
		return tsunami.geom.Ratio.defineRect(rect, rect.width * amount.decimalPercentage, rect.height * amount.decimalPercentage, snapToPixel);
	};
	*/
	
	c.scaleWidth = function(rect, height, snapToPixel) {
		return tsunami.geom.Ratio.defineRect(rect, height * tsunami.geom.Ratio.widthToHeight(rect), height, snapToPixel);
	};

	c.scaleHeight = function(rect, width, snapToPixel) {
		return tsunami.geom.Ratio.defineRect(rect, width, width * tsunami.geom.Ratio.heightToWidth(rect), snapToPixel);
	};
	
	c.scaleToFill = function(rect, bounds, snapToPixel) {
		var scaled = tsunami.geom.Ratio.scaleHeight(rect, bounds.width, snapToPixel);
		
		if (scaled.height < bounds.height) {
			scaled = tsunami.geom.Ratio.scaleWidth(rect, bounds.height, snapToPixel);
		}
		return scaled;
	};
	
	c.scaleToFit = function(rect, bounds, snapToPixel) {
		var scaled = tsunami.geom.Ratio.scaleHeight(rect, bounds.width, snapToPixel);
		
		if (scaled.height > bounds.height) {
			scaled = tsunami.geom.Ratio.scaleWidth(rect, bounds.height, snapToPixel);
		}
		scaled.x = (bounds.width - scaled.width) / 2;
		scaled.y = (bounds.height - scaled.height) / 2;
		return scaled;
	};
	
	c.defineRect = function(rect, width, height, snapToPixel) {
		var scaled = new tsunami.geom.Rectangle(0, 0, rect.width, rect.height);
		scaled.width = snapToPixel ? Math.round(width) : width;
		scaled.height = snapToPixel ? Math.round(height) : height;
		return scaled;
	};
	
}());
tsunami = this.tsunami || {};

(function() {
	
	tsunami.Task = function(delay) {
		this.construct(delay);
	}
	
	var p = tsunami.Task.prototype = new tsunami.EventDispatcher();

	p.constructEventDispatcher = p.construct;

	p.construct = function(delay) {
		this.constructEventDispatcher();
		this.delay = delay;
	}

	p.onProgress = function(event){};
	
	p._progress = 0;

	p.name = "unnamed";
	
	p.delay = null;
	
	p.progressive = false;

	p.start = function() {
		this._progress = 0;
		if (this.getDebug()) {
			console.log("task " + this.name + " start", this);
		}
		if (!isNaN(this.delay)) {
			setTimeout(this.delayComplete.bind(this), this.delay * 1000);
		} else {
			this.delayComplete();
		}
	};
	
	p.delayComplete = function() {

	};
	
	p.taskCompleted = function() {
		if (this.getDebug()) {
			console.log("task " + this.name + " end", this);
		}
		this._progress = 1;
		if (this.onComplete) {
			this.onComplete({target:this, currentTarget:this});
		}
	};

	p.destroyEventDispatcher = p.destroy;

	p.destroy = function() {
		this.destroyEventDispatcher();
		this.onComplete = null;
	};
	
	p.getProgress = function() {
		return this._progress;
	};
	
	p.toString = function() {
		return "[Task" + " name=" + this.name + "]";
	}
	
}());




tsunami = this.tsunami || {};

(function() {
	
	tsunami.TaskManager = function(tasks) {
		this.construct(tasks);
	};
	
	var p = tsunami.TaskManager.prototype = new tsunami.Task();

	p.constructTask = p.construct;

	p.construct = function(tasks) {
		this.constructTask();

		this.setTasks(tasks);
	};
	
	p.tasks = [];
	
	p.progressiveTasks = [];
	
	p.createdTasks = [];
	
	p.delayComplete = function() {
		this.createdTasks = [];
	};
	
	p.setTasks = function(value) {
		this.tasks = [];
		this.progressiveTasks = [];
		if (value) {
			for (var i = 0; i < value.length; i++) {
				this.addTask(value[i]);
			}
		}
		return this;
	};
	
	p.addTask = function(task) {
		if (task) {
			this.tasks.push(task);
			if (task.progressive) {
				this.progressiveTasks.push(task);
				this.progressive = true;
			}
			task.setDebug(this.getDebug());
		}
		return this;
	};
	
	p.addTaskAt = function(task, index) {
		if (task) {
			if (task.progressive) {
				this.progressiveTasks.push(task);
				this.progressive = true;
			}
			this.tasks.splice(index, 0, task);
			task.setDebug(this.getDebug());
		}
		return this;
	};
	
	p.contains = function(task) {
		return this.tasks.indexOf(task) != -1;
	};
	
	p.getTaskAt = function(index) {
		return this.tasks[index];
	};
	
	p.getTaskByName = function(name) {
		var taskFound;
		for (var i = 0; i < this.tasks.length; i++) {
			var task = this.tasks[i];
			if (task.name == name) {
				taskFound = task;
			}
		}
		return taskFound;
	};
	
	p.getTaskIndex = function(task) {
		return this.tasks.indexOf(task);
	};
	
	p.removeTask = function(task) {
		var index = this.getTaskIndex(task);
		if (index != -1) {
			this.removeTaskAt(index);
		}
		return this;
	};
	
	p.removeTaskAt = function(index) {
		var task = this.getTaskAt[index];
		this.tasks.splice(index, 1);
		var progressiveIndex = this.progressiveTasks.indexOf(task);
		if (progressiveIndex != -1) {
			this.progressiveTasks.splice(progressiveIndex, 1);
		}
		this.progressive = (this.progressiveTasks.length > 0);
		return this;
	};
	

	p.setTaskIndex = function(task, index) {
		var taskIndex = this.getTaskIndex(task);
		if (taskIndex != -1) {
			this.tasks.splice(index, 0, this.tasks[taskIndex]);
			this.tasks.splice(taskIndex, 1);
		}
	};
	
	p.swapTasksAt = function(index1, index2) {
		var temp = this.tasks[index1];
		this.tasks[index1] = this.tasks[index2];
		this.tasks[index2] = temp;
		return this;
	};

	p.getProgress = function() {
		var loadedProgress = 0;
		for (var i = 0; i < this.progressiveTasks.length; i++) {
			loadedProgress += this.progressiveTasks[i].getProgress();
		}
		var theValue = loadedProgress / Math.max(this.progressiveTasks.length, 1);
		if (this.debugPreload) {
			console.log("getProgress", theValue, "progressiveTasks.length", this.progressiveTasks.length);
		}
		return theValue;
	};

	p.setDebugTask = p.setDebug;
		
	p.setDebug = function(value) {
		this.setDebugTask(value);
		for (var i = 0; i < this.tasks.length; i++) {
			this.tasks[i].setDebug(value);
		}
	};

	p.destroyTask = p.destroy;

	p.destroy = function() {
		for (var i = 0; i < this.tasks.length; i++) {
			this.tasks[i].destroy();
		}
		this.task = null;
		this.progressiveTasks = null;
		this.createdTasks = null;

		this.destroyTask();
	};

}());




tsunami = this.tsunami || {};

(function() {
	
	tsunami.Parallel = function(tasks) {
		this.construct(tasks);
	};
	
	var p = tsunami.Parallel.prototype = new tsunami.TaskManager();

	p.constructTaskManager = p.construct;

	p.construct = function(tasks) {
		this.constructTaskManager(tasks);

		this.name = "parallel";
	};
	
	p.delayCompleteTaskManager = p.delayComplete;
	
	p.delayComplete = function() {
		this.delayCompleteTaskManager();
		if (this.tasks.length > 0) {
			for (var i = 0; i < this.tasks.length; i++) {
				var task = this.tasks[i];
				task.onComplete = this.onCompleteTask.bind(this);
				task.start();
			}
		} else {
			this.taskCompleted();
		}		
	};
	
	p.onCompleteTask = function(event) {
		var task = event.target;
		this.createdTasks.push(task);
		if (this.createdTasks.length == this.tasks.length) {
			this.taskCompleted();
		}
	};
	
	p.toString = function() {
		return "[Parallel" + " name=" + this.name + "]";
	};
	
}());




tsunami = this.tsunami || {};

(function() {
	
	tsunami.Series = function(tasks) {
		this.construct(tasks);
	};
	
	var p = tsunami.Series.prototype = new tsunami.TaskManager();
	
	p.constructTaskManager = p.construct;
	
	p.construct = function(tasks) {
		this.constructTaskManager(tasks);

		this.name = "series";
	};
	
	p.delayCompleteTaskManager = p.delayComplete;
	
	p.delayComplete = function() {
		this.delayCompleteTaskManager();
		if (this.tasks.length > 0) {
			this.createTask();
		} else {
			this.taskCompleted();
		}
	};
	
	p.createTask = function() {
		var index = this.createdTasks.length;
		var task = this.tasks[index];
		task.onComplete = this.onCompleteTask.bind(this);
		task.start();
	};
	
	p.onCompleteTask = function(event) {
		var task = event.target;
		task.onComplete = function(){};
		this.createdTasks.push(task);
		if (this.createdTasks.length == this.tasks.length) {
			this.taskCompleted();
		} else {
			this.createTask();
		}
	};
	
	p.toString = function() {
		return "[Series" + " name=" + this.name + "]";
	};
	
}());




tsunami = this.tsunami || {};

(function() {
	
	tsunami.Method = function(method, args, delay) {
		this.construct(method, args, delay);
	}

	var p = tsunami.Method.prototype = new tsunami.Task();

	p.constructTask = p.construct;

	p.construct = function(method, args, delay) {
		this.constructTask(delay);
		this.method = method;
		this.args = args;
	}

	p.delayComplete = function() {
		this.result = this.method.apply(null, this.args);
		this.taskCompleted();
	}
	
	p.destroyTask = p.destroy;
	
	p.destroy = function() {
		this.result = null;
		this.method = null;
		this.args = null;
		this.destroyTask();
	}
	
	p.toString = function() {
		return "[Method" + " name=" + this.name + "]";
	}
	
}());




tsunami = this.tsunami || {};

(function() {

	tsunami.TaskProxy = function(target, propertyName, args) {
		this.construct(target, propertyName, args);
	};

	var p = tsunami.TaskProxy.prototype = new tsunami.Task();

	p.constructTask = p.construct;

	p.construct = function(target, propertyName, args) {
		this.constructTask();
		this.target = target;
		this.propertyName = propertyName;
		this.args = args;
	};

	p.delayComplete = function() {
		this._progress = 0;
		var prop = this.target[this.propertyName];
		var type = typeof prop;
		if (type == 'function') {
			this.task = prop.bind(this.target).apply(null, this.args, this.target);
		}	else {
			this.task = prop;
		}
		if (this.task) {
			if (this.task.start) {
				this.task.onComplete = this.taskCompleted.bind(this);
				this.task.setDebug(this.getDebug());
				this.task.start();
			} else {
				throw "TaskProxy target and property name should return a Task interface";
				this.taskCompleted();
			}
		} else {
			this.taskCompleted();
		}
	};

	p.taskCompletedTask = p.taskCompleted;

	p.taskCompleted = function() {
		this._progress = 1;
		this.taskCompletedTask();
	};

	p.getProgress = function() {
		if (this.task) {
			try {
				this._progress = this.task.getProgress();
			} catch(e) {

			}
		}
		return this._progress;
	};

	p.destroyFunction = p.destroy;

	p.destroy = function() {
		this.target = null;
		this.propertyName = null;
		this.args = null;
		if (this.task) {
			this.task.destroy();
		}
		this.destroyFunction();
	};

	p.toString = function() {
		return "[Function" + " name=" + this.name + "]";
	};

}());




tsunami = this.tsunami || {};

(function() {

	tsunami.Delay = function(delay) {
		this.construct(delay);
	}

	var p = tsunami.Delay.prototype = new tsunami.Task();

	p.delayComplete = function() {
		this.taskCompleted();
	};

	p.toString = function() {
		return "[Delay" + " name=" + this.name + "]";
	}

}());




tsunami = this.tsunami || {};

(function() {

	tsunami.XHR = function(url, method, data, requestHeaders) {
		this.construct(url, method, data, requestHeaders);
	};

	var p = tsunami.XHR.prototype = new tsunami.Task();

	p.constructTask = p.construct;

	p.construct = function(url, method, data, requestHeaders) {
		this.constructTask();

		this.url = url;
		if (!method) {
			method = "GET";
		}
		this.method = method;
		this.data = data;
		this.requestHeaders = requestHeaders;

		this.name = "XHR " + this.url;

		this.progressive = true;
	};

	p.delayComplete = function() {
		this.xhr = new XMLHttpRequest();
		this.xhr.onload = this.xhrLoad.bind(this);
		this.xhr.onprogress = this.xhrProgress.bind(this);
		this.xhr.onreadystatechange = this.xhrReadyStateChange.bind(this);

		var url2 = this.url;
		if (this.cacheBuster || tsunami.XHR.cacheBuster || tsunami.cacheBuster) {
			var random = Math.round(Math.random() * 1000000000);
			if (url2.indexOf("?") == -1) {
				url2 += "?"
			} else {
				url2 += "&"
			}
			url2 += "nocache=" + random.toString();
		}
		this.xhr.open(this.method, url2, true);
		if (this.requestHeaders) {
			for (var i=0; i < this.requestHeaders.length; i++) {
				var requestHeader = this.requestHeaders[i];
				this.xhr.setRequestHeader(requestHeader[0], requestHeader[1]);
			}
		}
		if (this.data) {
			this.xhr.send(this.data);
		} else {
			this.xhr.send();
		}
	};

	p.xhrProgress = function(event) {
		this._progress = event.loaded / event.total;
		this.onProgress({target:this, value:this._progress});
	};

	p.xhrLoad = function(event) {
		this.responseText = this.xhr.responseText;
		this.taskCompleted();
	};

	p.xhrReadyStateChange = function() {
		//console.log("xhr.status", this.xhr.status);
		//console.log("xhr.readyState", this.xhr.readyState);
	};

	p.destroyTask = p.destroy;

	p.destroy = function() {

		this.url = null;
		this.method = null;

		if (this.xhr) {
			this.xhr.onload = function(){};
			this.xhr.onprogress = function(){};
			this.xhr = null;
		}
		this.destroyTask();
	};

	p.toString = function() {
		return "[XHR" + " name=" + this.name + " url=" + this.url + "]";
	};

}());


tsunami = this.tsunami || {};

(function() {
	
	tsunami.Image = function(url, image, useXHR) {
		this.construct(url, image, useXHR);
	}
	
	var p = tsunami.Image.prototype = new tsunami.Task();

	p.constructTask = p.construct;

	p.construct = function(url, image, useXHR) {
		this.constructTask();

		this.url = url;
		this.image = image;
		if (!this.image) {
			this.image = new Image();
		}
		this.useXHR = useXHR;

		this.name = this.url;

		this.progressive = true;
	};
	
	p.delayComplete = function() {
		if (this.useXHR) {
			try {
				this.useXHR = URL;
			} catch (e) {
				this.useXHR = false;
			}
		}

		if (this.useXHR) {
			this.xhr = new XMLHttpRequest();
			this.xhr.onload = this.xhrLoad.bind(this);
			this.xhr.onprogress = this.xhrProgress.bind(this);
			this.xhr.open("GET", this.url, true);
			this.xhr.responseType = "blob";
			this.xhr.send();
		} else {
			if (this.image.src.indexOf(this.url) == -1) {
				this.image.onload = this.imageLoad.bind(this);
				this.image.src = this.url;
			} else {
				this.imageLoad();
			}
		}
		//console.log(URL.createObjectURL);
	};
	
	p.xhrProgress = function(event) {
		this._progress = event.loaded / event.total;
		this.onProgress({target:this, value:this._progress});
	};
	
	p.xhrLoad = function(event) {
		this.image.onload = this.xhrImageLoad.bind(this);
		this.image.src = URL.createObjectURL(this.xhr.response);
	};

	p.xhrImageLoad = function() {
		URL.revokeObjectURL(this.image.src);
		this.imageLoad();
	};

	p.imageLoad = function() {
		this.image.onload = function(){};
		this.taskCompleted();
	};

	p.destroyTask = p.destroy;
	
	p.destroy = function() {
		this.url = null;
		this.image = null;
		if (this.xhr) {
			this.xhr.onload = function(){};
			this.xhr.onprogress = function(){};
			this.xhr = null;
		}
		this.destroyTask();
	};
	
	p.toString = function() {
		return "[Image" + " name=" + this.name + " url=" + this.url + "]";
	};
	
}());


(function() {

	tsunami.Element = function(p) {

		p.construct = function() {
		};

		p.hasClass = function (className) {
			return this.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
		};

		p.addClass = function (className) {
			if (!this.hasClass(className)) this.className += " " + className;
		};

		p.removeClass = function (className) {
			if (this.hasClass(className)) {
				var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
				this.className = this.className.replace(reg," ");
			}
		};

		p.replaceClass = function (oldClass, newClass) {
			this.removeClass(oldClass);
			this.addClass(newClass);
		};

		p.getSelector = function(selector) {
			return this.querySelectorAll(selector)[0];
		};

		p.construct();

		return p;

	}

}());


(function() {

	tsunami.DisplayObject = function(p) {

		tsunami.Element(p);

		p.construct = function() {
			this.units = {};
			this.units.marginTop = "px";
			this.units.marginBottom = "px";
			this.units.marginRight = "px";
			this.units.marginLeft = "px";
			this.units.width = "px";
			this.units.height = "px";
			this.units.left = "px";
			this.units.top = "px";
			this.units.right = "px";
			this.units.bottom = "px";
			this.units.translateX = "px";
			this.units.translateY = "px";
			this.units.translateZ = "px";

			this.transform = "";
		};

		p.getMarginTop = function() {
			return eval(this.style.marginTop.split(this.units.marginTop)[0]) || 0;
		};

		p.setMarginTop = function(value) {
			this.style.marginTop = value + this.units.marginTop;
		};

		p.getMarginBottom = function() {
			return eval(this.style.marginBottom.split(this.units.marginBottom)[0]) || 0;
		};

		p.setMarginBottom = function(value) {
			this.style.marginBottom = value + this.units.marginBottom;
		};

		p.getMarginRight = function() {
			return eval(this.style.marginRight.split(this.units.marginRight)[0]) || 0;
		};

		p.setMarginRight = function(value) {
			this.style.marginRight = value + this.units.marginRight;
		};

		p.getMarginLeft = function() {
			return eval(this.style.marginLeft.split(this.units.marginLeft)[0]) || 0;
		};

		p.setMarginLeft = function(value) {
			this.style.marginLeft = value + this.units.marginLeft;
		};

		p.getWidth = function() {
			return eval(this.style.width.split(this.units.width)[0]) || 0;
		};

		p.setWidth = function(value) {
			this.style.width = value + this.units.width;
		};

		p.getHeight = function() {
			return eval(this.style.height.split(this.units.height)[0]) || 0;
		};

		p.setHeight = function(value) {
			this.style.height = value + this.units.height;
		};

		p.getLeft = function() {
			return eval(this.style.left.split(this.units.left)[0]) || 0;
		};

		p.setLeft = function(value) {
			this.style.left = value + this.units.left;
		};

		p.getTop = function() {
			return eval(this.style.top.split(this.units.top)[0]) || 0;
		};

		p.setTop = function(value) {
			this.style.top = value + this.units.top;
		};

		p.getRight = function() {
			return eval(this.style.right.split(this.units.right)[0]) || 0;
		};

		p.setRight = function(value) {
			this.style.right = value + this.units.right;
		};

		p.getBottom = function() {
			return eval(this.style.bottom.split(this.units.bottom)[0]) || 0;
		};

		p.setBottom = function(value) {
			this.style.bottom = value + this.units.bottom;
		};

		p.getOpacity = function() {
			return (isNaN(this.opacity))?1:this.opacity;
		};

		p.setOpacity = function(value) {
			this.opacity = value;
			this.style.opacity = this.opacity;
			return this;
		};

		p.transformSpace = function() {
			return (this.transform)?" ":"";
		};

		p.getTranslateX = function() {
			return (isNaN(this.translateX))?0:this.translateX;
		};

		p.setTranslateX = function(value) {
			this.translateX = value;
			this.transform += this.transformSpace() + "translateX(" + value + this.units.translateX + ")";
		};

		p.getTranslateY = function() {
			return (isNaN(this.translateY))?0:this.translateY;
		};

		p.setTranslateY = function(value) {
			this.translateY = value;
			this.transform += this.transformSpace() + "translateY(" + value + this.units.translateY + ")";
		};

		p.getTranslateZ = function() {
			return (isNaN(this.translateZ))?0:this.translateZ;
		};

		p.setTranslateZ = function(value) {
			this.translateZ = value;
			this.transform += this.transformSpace() + "translateZ(" + value + this.units.translateZ + ")";
		};

		p.getScale = function() {
			return this.getScaleX();
		};

		p.setScale = function(value) {
			this.setScaleX(value);
			this.setScaleY(value);
		};

		p.getScaleX = function() {
			return (isNaN(this.scaleX))?1:this.scaleX;
		};

		p.setScaleX = function(value) {
			this.scaleX = value;
			this.transform += this.transformSpace() + "scaleX(" + value + ")";
		};

		p.getScaleY = function() {
			return (isNaN(this.scaleY))?1:this.scaleY;
		};

		p.setScaleY = function(value) {
			this.scaleY = value;
			this.transform += this.transformSpace() + "scaleY(" + value + ")";
		};

		p.getScaleZ = function() {
			return (isNaN(this.scaleZ))?1:this.scaleZ;
		};

		p.setScaleZ = function(value) {
			this.scaleZ = value;
			this.transform += this.transformSpace() + "scaleZ(" + value + ")";
		};

		p.getRotateX = function() {
			return (isNaN(this.rotateX))?0:this.rotateX;
		};

		p.setRotateX = function(value) {
			this.rotateX = value;
			this.transform += this.transformSpace() + "rotateX(" + value + "deg)";
		};

		p.getRotateY = function() {
			return (isNaN(this.rotateY))?0:this.rotateY;
		};

		p.setRotateY = function(value) {
			this.rotateY = value;
			this.transform += this.transformSpace() + "rotateY(" + value + "deg)";
		};

		p.getRotateZ = function() {
			return (isNaN(this.rotateZ))?0:this.rotateZ;
		};

		p.setRotateZ = function(value) {
			this.rotateZ = value;
			this.transform += this.transformSpace() + "rotateZ(" + value + "deg)";
		};

		p.getRotate = function() {
			return (isNaN(this.rotate))?0:this.rotate;
		};

		p.setRotate = function(value) {
			this.rotate = value;
			this.transform += this.transformSpace() + "rotate(" + value + "deg)";
		};

		p.getSkewX = function() {
			return (isNaN(this.skewX))?0:this.skewX;
		};

		p.setSkewX = function(value) {
			this.skewX = value;
			this.transform += this.transformSpace() + "skewX(" + value + "deg)";
		};

		p.getSkewY = function() {
			return (isNaN(this.skewY))?0:this.skewY;
		};

		p.setSkewY = function(value) {
			this.skewY = value;
			this.transform += this.transformSpace() + "skewY(" + value + "deg)";
		};

		p.updateTransform = function() {
			var style = this.style;
			var transform = this.getTransform();
			style.msTransform = transform;
			style.webkitTransform = transform;
			//style.oTransform = transform;
			style.transform = transform;
			this.setTransform("");
		};

		p.setTransform = function(value) {
			this.transform = value;
		};

		p.getTransform = function() {
			return this.transform;
		};

		p.construct();

		return p;

	};

}());


tsunami = this.tsunami || {};

(function() {

	tsunami.List = function(o) {

		o.construct = function() {
			var templateSelector = this.getAttribute("template");
			if (templateSelector) {
				var script = document.querySelector(templateSelector);
				this.template = script.text;
			}
			var array = eval(this.getAttribute("dataProvider"));
			if (array && this.template) {
				this.setDataProvider(array);
			}
		};

		o.getDataProvider = function() {
			return this._dataProvider;
		};

		o.setDataProvider = function(value) {
			this.innerHTML = "";
			this._dataProvider = value;
			for (var i = 0; i < value.length; i++) {
				var model = value[i];
				var object = tsunami.utils.createElement(this.template, this, "wrapper", model, i);
			}
		};

		o.construct();

		return o;

	};

}());


tsunami = this.tsunami || {};

(function() {

	tsunami.DataBind = function(o) {

		o.construct = function() {
			this.model = eval(this.innerHTML);
			if (this.model.isData) {
				this.model.addEventListener("change", this.modelChange.bind(this));
				this.modelChange(null);
			} else {
				this.innerHTML = this.model;
			}
		}

		o.modelChange = function(event) {
			this.innerHTML = this.model.getValue();
		}

		o.construct();

		return o;

	}

}());


tsunami.Button = function(o) {

	o.construct = function() {
		this.onRelease = function(){};

		if (tsunami.utils.isMobile.any) {
			this.ontouchend = this.clickHandler.bind(this);
			this.onclick = this.cancelClick.bind(this);
		} else {
			this.onclick = this.clickHandler.bind(this);
		}
	};

	o.dontClickAfterDrag = function() {
		this.touchMoveHandler = this.touchMove.bind(this);
		this.ontouchstart = this.touchStart.bind(this);
	};

	o.touchStart = function(event) {
		var mouse = event.touches[0];
		this.touchStartPoint = new tsunami.geom.Point(mouse.pageX, mouse.pageY);
		document.removeEventListener("touchmove", this.touchMoveHandler);
		document.addEventListener("touchmove", this.touchMoveHandler);
	};

	o.touchMove = function(event) {
		var mouse = event.touches[0];
		var touchMovePoint = new tsunami.geom.Point(mouse.pageX, mouse.pageY);

		var distance = tsunami.geom.Point.distance(touchMovePoint, this.touchStartPoint);
		if (distance > 10) {
			this.invalidTouchend = true;
		}
	};

	o.cancelClick = function(event) {
		event.preventDefault();
	};

	o.clickHandler = function(event) {
		event.preventDefault();
		document.removeEventListener("touchmove", this.touchMoveHandler);
		if (this.invalidTouchend) {
			this.invalidTouchend = false;
			return;
		}
		this.onReleaseEvent(event);
	};

	o.onReleaseEvent = function(event) {
		this.onRelease(event);
	};

	o.construct();

	return o;

};

tsunami.RouterButton = function(o) {

	tsunami.Button(o);

	var router = o.getAttribute("router");
	if (router) {
		o.router = eval(router);
	}

	var pushState = o.getAttribute("pushstate");
	if (pushState) {
		o.pushState = eval(pushState);
	}

	o.onReleaseEventButton = o.onReleaseEvent;

	o.onReleaseEvent = function(event) {
		this.onReleaseEventButton(event);

		if (this.router) {
			var path = this.getPath();
			if (path) {
				this.router.setLocation(path, this.pushState);
			}
		} else {
			throw("No router on RouterButton", this);
		}
	};

	o.getPath = function() {
		return this.href;
	};

	return o;

};
tsunami = this.tsunami || {};

(function() {

	tsunami.Attribute = function(element, attributeName, value, unit) {
		this.construct(element, attributeName, value, unit);
	};

	var p = tsunami.Attribute.prototype = new tsunami.EventDispatcher();

	p.constructEventDispatcher = p.construct;

	p.construct = function(element, attributeName, value, unit) {
		this.constructEventDispatcher();
		this.isData = true;
		this.element = element;
		this.attributeName = attributeName;
		this.unit = unit;
		if (value) {
			this.setValue(value);
		}
	};

	p.setValue = function(value) {
		var string = value.toString();
		if (this.unit) {
			string += this.unit;
		}
		this.element.setAttribute(this.attributeName, string);
		this.dispatchEvent({type:"change", value:value});
	};

	p.getValue = function() {
		var value = this.element.getAttribute(this.attribute);
		if (this.unit) {
			value = value.split(this.unit)[0];
		}
		return value;
	};

}());




tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Back = function() {};

	tsunami.easing.Back.easeIn = function(t, b, c, d, s) {
		if (!s)
			s = 1.70158;
		return c * (t /= d) * t * ((s + 1) * t - s) + b;
	};

	tsunami.easing.Back.easeOut = function(t, b, c, d, s) {
		if (!s)
			s = 1.70158;
		return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
	};

	tsunami.easing.Back.easeInOut = function(t, b, c, d, s) {
		if (!s)
			s = 1.70158;
		if ((t /= d / 2) < 1)
			return c / 2 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
		return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
	};

}());


tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Bounce = function() {};

	tsunami.easing.Bounce.easeOut = function(t, b, c, d) {
		if ((t /= d) < (1 / 2.75))
			return c * (7.5625 * t * t) + b;
		else if (t < (2 / 2.75))
			return c * (7.5625 * (t -= (1.5 / 2.75)) * t + 0.75) + b;
		else if (t < (2.5 / 2.75))
			return c * (7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375) + b;
		else
			return c * (7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375) + b;
	};

	tsunami.easing.Bounce.easeIn = function(t, b, c, d) {
		return c - tsunami.easing.Bounce.easeOut(d - t, 0, c, d) + b;
	};

	tsunami.easing.Bounce.easeInOut = function(t, b, c, d) {
		if (t < d/2)
			return tsunami.easing.Bounce.easeIn(t * 2, 0, c, d) * 0.5 + b;
		else
			return tsunami.easing.Bounce.easeOut(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
	};

}());
tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Circular = function() {
	};

	tsunami.easing.Circular.easeIn = function(t, b, c, d) {
		return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
	};

	tsunami.easing.Circular.easeOut = function(t, b, c, d) {
		return c * Math.sqrt(1 - (t = t/d - 1) * t) + b;
	};

	tsunami.easing.Circular.easeInOut = function(t, b, c, d) {
		if ((t /= d / 2) < 1)
			return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
		return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
	};

}());



tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Cubic = function() {
	};

	tsunami.easing.Cubic.easeIn = function(t, b, c, d) {
		return c * (t /= d) * t * t + b;
	};

	tsunami.easing.Cubic.easeOut = function(t, b, c, d) {
		return c * ((t = t / d - 1) * t * t + 1) + b;
	};

	tsunami.easing.Cubic.easeInOut = function(t, b, c, d) {
		if ((t /= d / 2) < 1)
			return c / 2 * t * t * t + b;

		return c / 2 * ((t -= 2) * t * t + 2) + b;
	};

}());
tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Elastic = function() {};

	tsunami.easing.Elastic.easeIn = function(t, b, c, d, a, p) {
		if (t == 0)
			return b;
		if ((t /= d) == 1)
			return b + c;
		if (!p)
			p = d * 0.3;
		var s;
		if (!a || a < Math.abs(c)) {
			a = c;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(c / a);
		}
		return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
	};

	tsunami.easing.Elastic.easeOut = function(t, b, c, d, a, p) {
		if (t == 0)
			return b;
		if ((t /= d) == 1)
			return b + c;
		if (!p)
			p = d * 0.3;
		var s;
		if (!a || a < Math.abs(c)) {
			a = c;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(c / a);
		}
		return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
	};

	tsunami.easing.Elastic.easeInOut = function(t, b, c, d, a, p) {
		if (t == 0)
			return b;
		if ((t /= d / 2) == 2)
			return b + c;
		if (!p)
			p = d * (0.3 * 1.5);
		var s;
		if (!a || a < Math.abs(c)) {
			a = c;
			s = p / 4;
		} else {
			s = p / (2 * Math.PI) * Math.asin(c / a);
		}
		if (t < 1) {
			return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) /p)) + b;
		}
		return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p ) * 0.5 + c + b;
	};

}());
tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Exponential = function() {};

	tsunami.easing.Exponential.easeIn = function(t, b, c, d) {
		return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
	};

	tsunami.easing.Exponential.easeOut = function(t, b, c, d) {
		return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
	};

	tsunami.easing.Exponential.easeInOut = function(t, b, c, d) {
		if (t == 0)
			return b;

		if (t == d)
			return b + c;

		if ((t /= d / 2) < 1)
			return c / 2 * Math.pow(2, 10 * (t - 1)) + b;

		return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
	};

}());
tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Linear = function() {};

	tsunami.easing.Linear.easeIn = function(t, b, c, d) {
		return c * t / d + b;
	};

	tsunami.easing.Linear.easeOut = function(t, b, c, d) {
		return c * t / d + b;
	};

	tsunami.easing.Linear.easeInOut = function(t, b, c, d) {
		return c * t / d + b;
	};

}());
tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Quadratic = function() {
	}

	tsunami.easing.Quadratic.easeIn = function(t, b, c, d) {
		return c * (t /= d) * t + b;
	}

	tsunami.easing.Quadratic.easeOut = function(t, b, c, d) {
		return -c * (t /= d) * (t - 2) + b;
	}

	tsunami.easing.Quadratic.easeInOut = function(t, b, c, d) {
		if ((t /= d / 2) < 1)
			return c / 2 * t * t + b;

		return -c / 2 * ((--t) * (t - 2) - 1) + b;
	}

}());
tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Quartic = function() {};

	tsunami.easing.Quartic.easeIn = function(t, b, c, d) {
		return c * (t /= d) * t * t * t + b;
	};

	tsunami.easing.Quartic.easeOut = function(t, b, c, d) {
		return -c * ((t = t / d - 1) * t * t * t - 1) + b;
	};

	tsunami.easing.Quartic.easeInOut = function(t, b, c, d) {
		if ((t /= d / 2) < 1)
			return c / 2 * t * t * t * t + b;

		return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
	};

}());
tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Quintic = function() {
	};

	tsunami.easing.Quintic.easeIn = function(t, b, c, d) {
		return c * (t /= d) * t * t * t * t + b;
	};

	tsunami.easing.Quintic.easeOut = function(t, b, c, d) {
		return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
	};

	tsunami.easing.Quintic.easeInOut = function(t, b, c, d) {
		if ((t /= d / 2) < 1)
			return c / 2 * t * t * t * t * t + b;

		return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
	};

}());
tsunami = this.tsunami || {};
tsunami.easing = tsunami.easing || {};

(function() {

	tsunami.easing.Sine = function() {
	};

	tsunami.easing.Sine.easeIn = function(t, b, c, d) {
		return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
	};

	tsunami.easing.Sine.easeOut = function(t, b, c, d) {
		return c * Math.sin(t / d * (Math.PI / 2)) + b;
	};

	tsunami.easing.Sine.easeInOut = function(t, b, c, d) {
		return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
	};

}());
tsunami = this.tsunami || {};

(function() {

	tsunami.Tween = function(startFrame, duration, target, properties, setters, easing, changeHandler, completeHandler) {
		this.construct(startFrame, duration, target, properties, setters, easing, changeHandler, completeHandler);
	};

	var p = tsunami.Tween.prototype = new tsunami.Task();

	var c = tsunami.Tween;

	c.COMPLETE = "complete";

	c.CHANGE = "change";

	c.clock = new tsunami.EventDispatcher();

	c.clock.tick = function() {
		tsunami.Tween.clock.dispatchEvent({type:"tick"});
	};

	p.constructTask = p.construct;

	p.construct = function(startFrame, duration, target, properties, setters, easing, changeHandler, completeHandler) {
		this.constructTask();
		this.startFrame = startFrame;
		this.duration = duration;
		this.target = target;
		this.properties = properties || [];
		this.setters = setters || [];
		this.easing = easing;
		this.changeHandler = changeHandler;
		this.completeHandler = completeHandler;
		this.currentFrame = this.startFrame;
		this.currentFrameTarget = this.startFrame;
		this.updateEase = 0.1;
		this.tickHandler = this.tick.bind(this);
	};

	p.start = function() {
		this.setCurrentFrame(this.startFrame);
		tsunami.Tween.clock.addEventListener("tick", this.tickHandler);
	};

	p.update = function() {
		this.setCurrentFrame(this.currentFrame + (this.currentFrameTarget - this.currentFrame) * this.updateEase);
	};

	p.stop = function() {
		tsunami.Tween.clock.removeEventListener("tick", this.tickHandler);
	};

	p.getCurrentFrame = function() {
		return this.currentFrame;
	};

	p.setCurrentFrame = function(value) {
		this.currentFrame = value;
		var frame = value - this.startFrame;
		for (var i in this.properties) {
			var array = this.properties[i];
			var tweened = this.easing(frame, array[0], array[1], this.duration);
			this.target[i] = tweened;
		}
		for (var i in this.setters) {
			var array = this.setters[i];
			var tweened = this.easing(frame, array[0], array[1], this.duration);
			this.target[i](tweened);
		}
		var changeEvent = {type:tsunami.Tween.CHANGE, target:this};
		if (this.changeHandler) {
			this.changeHandler(changeEvent);
		}
		this.dispatchEvent(changeEvent);
	};

	p.tick = function() {
		this.setCurrentFrame(this.currentFrame + 1);
		if (this.currentFrame >= this.startFrame + this.duration) {
			this.stop();
			if (this.completeHandler) {
				this.completeHandler();
			}
			this.dispatchEvent({type:tsunami.Tween.COMPLETE, target:this});
			this.taskCompleted();
		}
	};

}());
tsunami = this.tsunami || {};

(function() {

	tsunami.TimeTween = function(delay, duration, target, properties, methods, easing, changeHandler, completeHandler) {
		this.construct(delay, duration, target, properties, methods, easing, changeHandler, completeHandler);
	};

	var p = tsunami.TimeTween.prototype = new tsunami.Task();

	var c = tsunami.TimeTween;

	c.COMPLETE = "complete";

	c.CHANGE = "change";

	c.clock = new tsunami.EventDispatcher();

	c.clock.time = new Date();

	c.clock.tick = function() {
		tsunami.TimeTween.clock.time = new Date();
		tsunami.TimeTween.clock.dispatchEvent({type:"tick"});
	};

	p.constructTask = p.construct;

	p.construct = function(delay, duration, target, properties, methods, easing, changeHandler, completeHandler) {
		this.constructTask();
		this.startTime = delay;
		this.duration = duration;
		this.target = target;
		this.properties = properties || [];
		this.methods = methods || [];
		this.easing = easing;
		this.changeHandler = changeHandler;
		this.completeHandler = completeHandler;
		this.position = this.startTime;
		this.positionTarget = this.startTime;
		this.updateEase = 0.1;
		this.tickHandler = this.tick.bind(this);
	};

	p.start = function() {
		this.clockStartTime = tsunami.TimeTween.clock.time;
		this.setPosition(0);
		tsunami.TimeTween.clock.addEventListener("tick", this.tickHandler);
	};

	p.update = function() {
		this.setPosition(this.position + (this.positionTarget - this.position) * this.updateEase);
	};

	p.stop = function() {
		tsunami.TimeTween.clock.removeEventListener("tick", this.tickHandler);
	};

	p.getPosition = function() {
		return this.position;
	};

	p.setPosition = function(value) {
		this.position = value;
		var time = Math.max(value - this.startTime, 0);
		time = Math.min(this.duration, time);
		for (var i in this.properties) {
			var array = this.properties[i];
			var tweened = this.easing(time, array[0], array[1], this.duration);
			this.target[i] = tweened;
		}
		for (var i in this.methods) {
			var array = this.methods[i];
			var tweened = this.easing(time, array[0], array[1], this.duration);
			this.target[i](tweened);
		}
		var changeEvent = {type:tsunami.TimeTween.CHANGE, target:this};
		if (this.changeHandler) {
			this.changeHandler(changeEvent);
		}
		this.dispatchEvent(changeEvent);
	};

	p.tick = function() {
		this.setPosition((tsunami.TimeTween.clock.time - this.clockStartTime) / 1000);
		if (this.position >= this.startTime + this.duration) {
			this.stop();
			if (this.completeHandler) {
				this.completeHandler();
			}
			this.dispatchEvent({type:tsunami.TimeTween.COMPLETE, target:this});
			this.taskCompleted();
		}
	};

}());
tsunami = this.tsunami || {};

(function() {

	tsunami.Timeline = function() {
		this.currentFrame = 0;

		this.currentFrameTarget = this.currentFrame;
		this.currentFrameRace = this.currentFrame;
		this.updateEase = 0.1;

		this.actions = [];
		this.tweens = [];

		this.minFrameReached = 0;
		this.maxFrameReached = 0;

	};

	var p = tsunami.Timeline.prototype;

	p.getCurrentFrame = function() {
		return this.currentFrame;
	};

	p.setCurrentFrame = function(value) {
		var oldFrame = this.currentFrame;
		if (oldFrame == value) {
			return;
		}

		this.currentFrame = value;

		//console.log("oldFrame", oldFrame, "value", value);

		this.minFrameReached = Math.min(this.minFrameReached, value);
		this.maxFrameReached = Math.max(this.maxFrameReached, value);
		//console.log("minFrameReached", this.minFrameReached, "maxFrameReached", this.maxFrameReached);

		var min;
		var max;
		var direction;
		if (this.currentFrame > oldFrame) {
			direction = tsunami.TimelineAction.FORWARDS;
			min = oldFrame;
			max = value;
		}
		if (this.currentFrame < oldFrame) {
			direction = tsunami.TimelineAction.BACKWARDS;
			min = value;
			max = oldFrame;
		}

		//console.log("direction", direction);
		if (direction) {
			var selectedActions = [];

			if (direction == tsunami.TimelineAction.FORWARDS) {
				for (var i = 0; i < this.actions.length; i++) {
					var action = this.actions[i];
					if (action.direction == direction || action.direction == "both") {
						if (action.position > min && action.position <= max) {
							selectedActions.push(action);
						}
					}
				}
				selectedActions.sort(function(a, b){
					return a.position- b.position;
				});
			}
			if (direction == tsunami.TimelineAction.BACKWARDS) {
				for (var i = 0; i < this.actions.length; i++) {
					var action = this.actions[i];
					if (action.direction == direction || action.direction == "both") {
						if (action.position >= min && action.position < max) {
							selectedActions.push(action);
						}
					}
				}
				selectedActions.sort(function(a, b){
					return b.position-a.position;
				});
			}
			for (var j = 0; j < selectedActions.length; j++) {
				var selectedAction = selectedActions[j];
				selectedAction.count++;
				if (selectedAction.count >= selectedAction.repeat) {
					this.removeFrame(selectedAction);
				}
				selectedAction.execute();
			}
		}

		for (var i = 0; i < this.tweens.length; i++) {
			var tween = this.tweens[i];
			var startFrame = tween.startFrame;
			var endFrame = tween.startFrame + tween.duration;
			if (value >= startFrame && value <= endFrame) {
				tween.setCurrentFrame(value);
			} else if (direction == tsunami.TimelineAction.FORWARDS && value > endFrame && tween.currentFrame != endFrame && endFrame >= this.minFrameReached ) {
				//console.log("FORWARDS", tween.toString());
				tween.setCurrentFrame(endFrame);
			} else if (direction == tsunami.TimelineAction.BACKWARDS && value < startFrame && tween.currentFrame != startFrame && this.maxFrameReached > startFrame) {
				//console.log("BACKWARDS", tween.toString());
				tween.setCurrentFrame(startFrame);
			}
		}
	};


	p.addAction = function(action) {
		this.actions.push(action);
		if (action.position == this.currentFrame) {
			action.method();
		}
	};

	p.removeAction = function(action) {
		var array = [];
		for (var i = 0; i < this.actions.length; i++) {
			var oldAction = this.actions[i];
			if (oldAction != action) {
				array.push(oldAction);
			}
		}
		this.actions = array;
	};

	p.addTween = function(tween) {
		this.tweens.push(tween);
		var startFrame = tween.startFrame;
		var endFrame = tween.startFrame + tween.duration;
		if (this.currentFrame >= startFrame && this.currentFrame <= endFrame) {
			tween.setCurrentFrame(this.currentFrame);
		}
	};

	p.removeTween = function(tween) {
		var array = [];
		for (var i = 0; i < this.tweens.length; i++) {
			var oldTween = this.tweens[i];
			if (oldTween != tween) {
				array.push(oldTween);
			}
		}
		this.tweens = array;
	};

	p.update = function() {
		this.currentFrameRace = this.currentFrameRace + (this.currentFrameTarget - this.currentFrameRace) * this.updateEase;
		this.setCurrentFrame(Math.round(this.currentFrameRace * 1000) / 1000);
	};


}());

(function() {

	tsunami.TimelineAction = function(method, position, direction, repeat) {
		this.method = method;
		this.position = position;
		this.direction = direction;
		if (isNaN(repeat)) {
			repeat = Infinity;
		}
		this.repeat = repeat;
		this.count = 0;
	};

	tsunami.TimelineAction.FORWARDS = "forwards";
	tsunami.TimelineAction.BACKWARDS = "backwards";
	tsunami.TimelineAction.BOTH = "both";
	
	var p = tsunami.TimelineAction.prototype;

	p.execute = function() {
		this.method();
	};

}());
(function() {

	tsunami.AnimationFrame = function(dispatchFramesPerSeconds) {
		this.construct(dispatchFramesPerSeconds);
	}

	var p = tsunami.AnimationFrame.prototype = new tsunami.EventDispatcher();

	tsunami.AnimationFrame.FRAME = "frame";
	tsunami.AnimationFrame.FPS = "fps";

	p.constructEventDispatcher = p.construct;

	p.construct = function(dispatchFramesPerSeconds) {
		this.index = 0;
		this.seconds = 0;
		this.allFrames = 0;
		this.animationFrame();
		if (dispatchFramesPerSeconds) {
			setTimeout(this.dispatchFrameSeconds.bind(this), 1000);
		}
	}

	p.animationFrame = function() {
		this.index++;
		this.dispatchEvent({type:tsunami.AnimationFrame.FRAME});
		window.requestAnimationFrame(this.animationFrame.bind(this));
	}

	p.dispatchFrameSeconds = function() {
		this.allFrames += this.index;
		this.seconds++;
		this.dispatchEvent({type:tsunami.AnimationFrame.FPS, frames:this.index, averageFrames:Math.round(this.allFrames / this.seconds * 10) / 10});
		this.index = 0;
		setTimeout(this.dispatchFrameSeconds.bind(this), 1000);
	}


}());






tsunami = this.tsunami || {};

(function () {

	tsunami.Branch = function(id, branches, defaultBranch) {
		this.construct(id, branches, defaultBranch);
	};

	var p = tsunami.Branch.prototype;

	p.construct = function(id, branches, defaultBranch) {
		this.id = id;
		this.branches = branches || [];
		this.defaultBranch = defaultBranch;
	};

	p.getBranch = function(id) {
		for (var i = 0; i < this.branches.length; i++) {
			var branch = this.branches[i];
			if (branch.id == id) {
				return branch;
			}
		}
	};

	p.getDefaultBranch = function() {
		return this.defaultBranch;
	};

	p.load = function() {
		console.log("tsunami.Branch.load", this.id);
	};

	p.show = function() {
		console.log("tsunami.Branch.show", this.id);
	};

	p.hide = function() {
		console.log("tsunami.Branch.hide", this.id);
	};

}());
tsunami = this.tsunami || {};

(function() {

	tsunami.BranchElement = function(o) {

		if (!o) {
			o = {};
		}

		o.path = "";

		o.branches = [];

		o.addBranch = function(branch) {
			this.branches.push(branch);
		};

		o.getBranch = function(id) {
			return this.querySelector("#" + id);
		};

		o.getDefaultBranch = function() {
			return this.defaultBranch;
		};

		o.load = function() {
			//console.log(this.id, "load");
		};

		o.show = function() {
			//console.log(this.id, "show");
		};

		o.hide = function() {
			//console.log(this.id, "hide");
		};

		o.toString = function() {
			return "[BranchElement" + " id=" + this.id + "]";
		};

		return o;

	}


}());




tsunami = this.tsunami || {};

(function() {

	tsunami.HistoryFallback = {
		HASH:"hash",
		RELOAD:"reload"
	};

	tsunami.History = function() {
		this.construct();
	};
	
	var p = tsunami.History.prototype = new tsunami.EventDispatcher();

	p.constructEventDispatcher = p.construct;

	p.construct = function() {
		this.constructEventDispatcher();

		this.hasPushed = false;

		this.fragment = "";
		
		this.hash = "#!";

		this.state = null;
		this._updateOnHashChange = true;

		this.historyIsAvailable = (history.pushState)?true:false;

		if (this.historyIsAvailable) {
			window.onpopstate = this._popStateHandler.bind(this);
		} else if (this.fallback == "hashChange") {
			window.onhashchange = this._hashChangeHandler.bind(this);
		}
	};

	p.start = function(base, fragment) {
		this.base = base;
		this.fragment = fragment;

		this.state = {};
		if (location.hash.indexOf(this.hash) != -1) {
			this.state.path = base + fragment + window.location.hash.split(this.hash)[1];
			if (this.state.path != base && this.historyIsAvailable) {
				history.replaceState(this.state, "", this.state.path);
			}
		} else {
			this.state.path = window.location.href;
			if (this.state.path != base) {
				if (!this.historyIsAvailable) {
					if (this.fallback == tsunami.HistoryFallback.HASH) {
						if (!location.hash) {
							var deeplink = this.state.path.split(base)[1];
							this._updateOnHashChange = false;
							console.log("1");
							location.replace(base + this.hash + deeplink);
						}
					} else if(this.fallback == tsunami.HistoryFallback.RELOAD) {
						if (location.hash) {
							console.log("2");
							location.replace(base + fragment + this.state.path);
						}
					}
				} else {
					//console.log("3");
					//this.replaceState({path:this.state.path}, "", this.state.path);
				}
			}
		}
		//console.log("4");
		this.dispatchEvent({type:"popstate", state:{path:this.state.path}});
	};

	p.pushState = function(state, title, url) {
		this.hasPushed = true;

		this.state = state;
		if (this.historyIsAvailable) {
			history.pushState(this.state, title, url);
		} else if (this.fallback == tsunami.HistoryFallback.HASH) {
			this._updateOnHashChange = false;
			window.location.href = this.hash + this.state.path.split(this.base + this.fragment)[1];
		} else if(this.fallback == tsunami.HistoryFallback.RELOAD) {
			location.assign(url);
		}
	};

	p.replaceState = function(state, title, url) {
		this.state = state;
		if (this.historyIsAvailable) {
			history.replaceState(this.state, title, url);
		} else if (this.fallback == tsunami.HistoryFallback.HASH) {
			this._updateOnHashChange = false;
			location.replace(this.hash + this.state.path);
		} else if(this.fallback == tsunami.HistoryFallback.RELOAD) {
			location.replace(url);
		}
	};

	p._popStateHandler = function(event) {
		if (!this.hasPushed) {
			return;
		}
		this.state = event.state;
		this.dispatchEvent({type:"popstate", state:event.state});
	};

	p._hashChangeHandler = function(e) {
		if (this._updateOnHashChange) {
			var path = location.hash.split(this.hash)[1] || "";
			this.state = {path:this.base + this.fragment + path};
			this.dispatchEvent({type:"popstate", state:this.state});
		} else {
			this._updateOnHashChange = true;
		}
	};

	tsunami.history = new tsunami.History();

}());

tsunami = this.tsunami || {};

(function() {

	tsunami.Router = function(root) {
		this.construct(root);
	};

	var p = tsunami.Router.prototype = new tsunami.EventDispatcher();

	p.constructEventDispatcher = p.construct;

	p.construct = function(root) {
		this.constructEventDispatcher();

		this._overrideLocation = null;
		this._branches = [];
		this._location = "";
		this.rewrites = {};
		this.fragment = "";
		this.path = "";
		this.root = root;
		this.popStateHandlerMethod = this.popStateHandler.bind(this);

		this.hideTasks = [{name:"hide", preload:false}];
		this.showTasks = [{name:"load", preload:true}, {name:"show", preload:false}];
	};

	p.getHistory = function() {
		return this._history;
	};

	p.setHistory = function(value) {
		if (this._history) {
			this._history.removeEventListener("popstate", this.popStateHandlerMethod);
		}
		this._history = value;
		if (this._history) {
			this._history.addEventListener("popstate", this.popStateHandlerMethod);
		}
	};

	p.popStateHandler = function(event) {
		//console.log("popStateHandler", event.state);
		if (event.state) {
			var path = event.state.path;
			this.setLocation(path, false);
		} else {
			this.setLocation(this.path, false);
		}
	};

	p.getLocation = function() {
		var array = this._location.split("/");
		array.shift();
		var locationPath = this.path;
		if (array.length > 0) {
			locationPath += this.fragment + array.join("/")
		}
		return locationPath;
	};

	p.setLocation = function(value, pushState) {
		if (this._debug) {
			console.log("setLocation", value);
		}
		value = this.getRewrite(value);
		if (value == this.getLocation() && this.hasLocation) {
			return;
		}
		var path = value.substr(this.path.length + this.fragment.length);
		if (path.indexOf("&" != -1)) {
			path = path.split("&")[0];
		}
		this._gotoLocation(path);
		if (this._history && pushState) {
			this._history.pushState({path:value}, "", value);
		}
	};

	p._getPath = function(array) {
		var path = "";
		for (var i = 0; i < array.length; i++) {
			path += array[i].id;
			if (i < array.length - 1) {
				path += "/";
			}
		}
		return path;
	};

	p._gotoLocation = function(value) {
		if (this._debug) {
			console.log("_gotoLocation", value);
		}
		this.dispatchEvent({type:"locationChange", location:value});
		this.hasLocation = true;
		this._overrideLocation = null;
		if (this._inTransition) {
			this._overrideLocation = value;
		} else {
			this._overrideLocation = null;
			this._nextLocation = "root";
			if (value != "") {
				this._nextLocation += "/" + value;
			}
			if (this._debug) {
				console.log("_nextLocation", this._nextLocation);
			}
			this._inTransition = true;
			this._hideOldBranches();
		}
	};

	p._hideOldBranches = function() {

		var oldBranches = [];
		var oldArray = this._location.split("/");
		var nextArray = this._nextLocation.split("/");

		var loop = true;
		var couldBeDefaultBranch = false;

		var breakIndex;
		var index = 0;
		var oldPath = "";
		var nextPath = "";
		while(isNaN(breakIndex) && index < nextArray.length) {
			oldPath = (oldPath == "")?oldPath:oldPath + "/";
			oldPath += oldArray[index];
			nextPath = (nextPath == "")?nextPath:nextPath + "/";
			nextPath += nextArray[index];
			if (nextPath != oldPath) {
				breakIndex = index - 1;
			}
			if (isNaN(breakIndex) && index == nextArray.length - 1) {
				breakIndex = index;
			}
			index++;
		}

		if (breakIndex >= 0) {
			for (var i = oldArray.length - 1; i > breakIndex; i--) {
				var path = oldArray.join("/");
				oldBranches.push(path);
				oldArray.pop();
			}
		}

		this._location = oldArray.join("/");
		if (this._location == this._nextLocation) {
			couldBeDefaultBranch = true;
		}

		if (couldBeDefaultBranch && oldBranches.length > 0) {
			var branchPath = this._nextLocation;
			var branch = this.getBranchFromPath(branchPath);
			while(branch) {
				if (branch.getDefaultBranch) {
					var id = branch.getDefaultBranch();
					if (id) {
						branchPath += "/" + id;
						var lastBranchPath = oldBranches[oldBranches.length - 1]
						if (branchPath == lastBranchPath) {
							this._nextLocation = oldBranches.pop();
							this._location = this._nextLocation;
						}
						branch = this.getBranchFromPath(branchPath);
					} else {
						branch = null;
					}
				} else {
					branch = null;
				}
			}
		}

		if (oldBranches.length > 0) {
			this._work("hide", oldBranches, "hide", this._hideComplete.bind(this));
		} else {
			this._hideComplete();
		}
	};

	p._hideComplete = function(event) {
		if (event) {
			event.target.destroy();
		}
		if (this._overrideLocation) {
			this._inTransition = false;
			this._gotoLocation(this._overrideLocation);
		} else {
			this._showNewBranches();
		}
	};

	p._work = function(transition, branches, transitionName, complete) {
		var taskNames = this[transitionName + "Tasks"];
		if (this._debug) {
			console.log("work", "transition", transition, "branches", branches, "transitionName", transitionName);
		}
		this._task = new tsunami.Series();
		this._task.name = transition;
		this._task.setDebug(this.getDebug());
		this._task.addTask(new tsunami.Method(this.dispatchEvent.bind(this), [{type:transition + "TaskStart"}]));
		for (var i = 0; i < taskNames.length; i++) {
			var transitionsTasks = new tsunami.Series();
			var taskName = taskNames[i].name;
			var newTask = new tsunami.Series();
			newTask.name = "transition " + taskName;
			var hasPreload = (taskNames[i].preload && this.preloader);
			if (hasPreload){
				var startPreload = new tsunami.Method(this._startPreload.bind(this), [transitionsTasks]);
				startPreload.name = null;
				newTask.addTask(startPreload);
				var showPreloader = new tsunami.TaskProxy(this.preloader, "show");
				showPreloader.name = "showPreloader";
				newTask.addTask(showPreloader);
			}
			newTask.addTask(transitionsTasks);
			var branchPath;
			for (var j = 0; j < branches.length; j++) {
				branchPath = branches[j];
				var proxyTask = new tsunami.TaskProxy(this, "getTaskFromBranchPath", [branchPath, taskName]);
				proxyTask.name = branchPath + "." + taskName;
				proxyTask.progressive = hasPreload;
				transitionsTasks.addTask(proxyTask);

				if (transitionName == "show" && taskName == taskNames[taskNames.length - 1].name) {
					transitionsTasks.addTask(new tsunami.Method(this.setLocationPath.bind(this), [branchPath]));
				}

			}
			if (transitionName == "show") {
				transitionsTasks.addTask(new tsunami.Method(this.checkForDefaultBranches.bind(this), [branchPath, transitionsTasks, taskName, taskNames, transitionName]));
			}
			if (hasPreload){
				var endPreload = new tsunami.Method(this._endPreload.bind(this), [newTask]);
				endPreload.name = null;
				newTask.addTask(endPreload);
				var hidePreloader = new tsunami.TaskProxy(this.preloader, "hide");
				hidePreloader.name = "hidePreloader";
				newTask.addTask(hidePreloader);
			}
			this._task.addTask(newTask);
		}
		this._task.addTask(new tsunami.Method(this.dispatchEvent.bind(this), [{type:transition + "TaskEnd"}]));
		this._task.onComplete = complete;
		this._task.start();
	};

	p.setLocationPath = function(path) {
		this._location = path;
	};

	p.checkForDefaultBranches = function(path, taskManager, taskName, taskNames, transitionName) {
		var branch = this.getBranchFromPath(path);
		if (branch) {
			if (branch.getDefaultBranch) {
				var id = branch.getDefaultBranch();
				if (id) {
					var branchPath = path + "/" + id;
					var newBranch = this.getBranchFromPath(branchPath);
					if (newBranch) {
						//this._nextLocation = branchPath;
						if (newBranch[taskName]) {
							var task = newBranch[taskName]();
							taskManager.addTask(task);
						}
						if (transitionName == "show" && taskName == taskNames[taskNames.length - 1].name) {
							taskManager.addTask(new tsunami.Method(this.setLocationPath.bind(this), [branchPath]));
						}
						taskManager.addTask(new tsunami.Method(this.checkForDefaultBranches.bind(this), [branchPath, taskManager, taskName, taskNames, transitionName]));
					}
				}
			}
		}
	};

	p._showNewBranches = function() {
		var newBranches = [];
		var pathArray = this._nextLocation.split("/");
		var loop = true;
		while (loop) {
			var branch = pathArray.join("/");
			if (this._location.indexOf(branch) == -1) {
				newBranches.unshift(branch);
				pathArray.pop();
			} else {
				loop = false;
			}
		}
		if (newBranches.length == 0) {
			var branch = this.getBranchFromPath(this._location);
			if (branch.getDefaultBranch) {
				var id = branch.getDefaultBranch();
				if (id) {
					var branchPath = this._location + "/" + id;
					newBranches.push(branchPath);
				}
			}
		}
		if (newBranches.length > 0) {
			this._location = newBranches[newBranches.length - 1];
			this._work("show", newBranches, "show", this._showComplete.bind(this));
		} else {
			this._showComplete();
		}
	};

	p._showComplete = function(event) {
		if (event) {
			event.target.destroy();
		}
		this._inTransition = false;
		this.dispatchEvent({type:"complete"});

		if (this._overrideLocation != null) {
			this._gotoLocation(this._overrideLocation);
		}
	};

	p._startPreload = function(task) {
		this._currentTask = task;
		//this._currentTask.debugPreload = true;
		this.preloader.setProgress(0);
		this._isMonitoringProgress = true;
		this._updatePreloader();
	};

	p._updatePreloader = function() {
		if (this._isMonitoringProgress) {
			var progress = this._currentTask.getProgress();
			this.preloader.setProgress(progress);
			window.requestAnimationFrame(this._updatePreloader.bind(this));
		}
	};

	p._endPreload = function(task) {
		this._currentTask = null;
		this.preloader.setProgress(1);
		this._isMonitoringProgress = false;
	};

	p.toString = function() {
		return "[Router]";
	};

	p.getBranch = function(id) {
		return this[id];
	};

	p.getTaskFromBranchPath = function(path, taskName) {
		var task;
		var branch = this.getBranchFromPath(path);
		if (branch) {
			if (branch[taskName]) {
				task = branch[taskName]();
			}
		}
		return task;
	};

	p.getBranchFromPath = function(path) {
		var array = path.split("/");
		var parent = this;
		for (var i = 0; i < array.length; i++) {
			var id = array[i];
			var branch;
			if (parent.getBranch) {
				branch = parent.getBranch(id);
			}
			if (branch) {
				branch.router = this;
				branch.root = this.root;
				if (branch == this.root) {
					branch.path = this.path;
				} else {
					branch.path = parent.path + (parent == this.root?this.fragment:"/") + id;
					branch.parent = parent;
				}
				parent = branch;
			} else {
				throw("Can't find branch " + id + " in " + parent);
				//console.log("Can't find branch " + id + " in " + parent.path);
				break;
			}
		}
		return branch;
	};

	p.rewrite = function(path, newPath) {
		this.rewrites[path] = newPath;
	};

	p.getRewrite = function(path) {
		var newPath = this.rewrites[path];
		return newPath || path;
	};

	p.destroy = function() {
		this.rewrites = null;
		this._overrideLocation = null;
		this._branches = null;
		this._location = null;
		this.rewrites = null;
		this.fragment = null;
		this.path = null;
		this.root = null;
		this.popStateHandlerMethod = null;

		this.hideTasks = null;
		this.showTasks = null;
	};

}());



fp = this.fp || {};

(function () {

	fp.MouseControls = function(camera) {
		this.camera = camera;
		this.camera.rotation.reorder( "YXZ" );

		document.body.addEventListener("mousemove", this.mouseMoveHandler.bind(this));

		this.rotationYTarget = 0;
		this.rotationXTarget = 0;

		this.halfSize = new tsunami.geom.Point(0.5, 0.5);
	};

	var p = fp.MouseControls.prototype;

	p.mouseMoveHandler = function(event) {
		var mouse = event;
		if (tsunami.utils.isMobile.any) {
			mouse = event.touches[0];
		}
		var mousePoint = new tsunami.geom.Point(mouse.pageX - window.pageXOffset, mouse.pageY - window.pageYOffset);
		var centerMouse = mousePoint.subtract(this.screenScaledHalfSize);
		var mouseOffset = centerMouse.divide(this.screenScaledHalfSize);

		/*
		if (mouseOffset.x > 0) {
			this.rotationYTarget = tsunami.easing.Sine.easeIn(mouseOffset.x, 0, 1, 1) * -135 * Math.PI / 180;
		} else {
			this.rotationYTarget = tsunami.easing.Sine.easeIn(mouseOffset.x, 0, -1, -1) * -135 * Math.PI / 180;
		}

		if (mouseOffset.y > 0) {
			this.rotationXTarget = tsunami.easing.Sine.easeIn(mouseOffset.y, 0, 1, 1) * -30 * Math.PI / 180;
		} else {
			this.rotationXTarget = tsunami.easing.Sine.easeIn(mouseOffset.y, 0, -1, -1) * -30 * Math.PI / 180;
		}
		*/

		this.rotationYTarget = mouseOffset.x * -67.5 * Math.PI / 180;
		this.rotationXTarget = mouseOffset.y * -30 * Math.PI / 180;
	};

	p.update = function(canvas) {
		this.camera.rotation.y += (this.rotationYTarget - this.camera.rotation.y) * 0.1;
		this.camera.rotation.x += (this.rotationXTarget - this.camera.rotation.x) * 0.1;
	};

	p.setCanvasSize = function(point) {
		this.screenScaledHalfSize = point.multiply(this.halfSize);
	};

}());

fp = this.fp || {};

(function () {

	fp.ScrollerMobile = function() {

		var o = new tsunami.EventDispatcher();

		o.construct = function() {
			this.pageXOffset = 0;
			this.pageYOffset = 0;
			this._scroll = new tsunami.geom.Point(this.pageXOffset, this.pageYOffset);
			this.touchStartScrollPoint = new tsunami.geom.Point();
			this.touchStartPoint = new tsunami.geom.Point();
			this.touchStartHandler = this.windowTouchStart.bind(this);
			this.touchMoveHandler = this.windowTouchMove.bind(this);
			this.touchEndHandler = this.windowTouchEnd.bind(this);
			window.addEventListener(tsunami.events.mousedown, this.touchStartHandler);
			window.addEventListener("resize", this.windowResize.bind(this));
		};

		o.windowResize = function() {
			var rect = tsunami.utils.getWindowRect();
			if (rect.width > this.pageSize.x - this._scroll.x || rect.height > this.pageSize.y - this._scroll.y) {
				this.updateScroll();
			}
		};

		o.windowTouchStart = function(event) {
			//event.preventDefault();
			var mouse = (tsunami.utils.isMobile.any)?event.touches[0]:event;
			this.touchStartScrollPoint.copyFrom(this._scroll);
			this.touchStartPoint.x = mouse.pageX;
			this.touchStartPoint.y = mouse.pageY;
			window.addEventListener(tsunami.events.mousemove, this.touchMoveHandler);
			window.addEventListener(tsunami.events.mouseup, this.touchEndHandler);
		};

		o.windowTouchMove = function(event) {
			event.preventDefault();
			var mouse = (tsunami.utils.isMobile.any)?event.touches[0]:event;
			this._scroll.x = this.touchStartScrollPoint.x + (this.touchStartPoint.x - mouse.pageX);
			this._scroll.y = this.touchStartScrollPoint.y + (this.touchStartPoint.y - mouse.pageY);
			this.updateScroll();
		};

		o.windowTouchEnd = function(event) {
			window.removeEventListener(tsunami.events.mousemove, this.touchMoveHandler);
			window.removeEventListener(tsunami.events.mouseup, this.touchEndHandler);
		};

		o.updateScroll = function() {
			var rect = tsunami.utils.getWindowRect();
			this._scroll.clamp(0, this.pageSize.x - rect.width, 0, this.pageSize.y - rect.height);
			this.pageXOffset = this._scroll.x;
			this.pageYOffset = this._scroll.y;
			this.dispatchEvent({type:"scroll"});
		};

		o.scroll = function(x, y) {
			this._scroll.x = x;
			this._scroll.y = y;
			this.updateScroll();
		};

		o.setPageSize = function(point) {
			this.pageSize = point;
		};

		o.getPageSize = function() {
			return this.pageSize;
		};

		o.construct();

		return o;

	};

}());
fp = this.fp || {};

(function () {

	fp.ScrollerDesktop = function(scrollArea) {

		window.scrollArea = scrollArea;

		window.setPageSize = function(point) {
			this.pageSize = point;
			this.scrollArea.style.width = point.x + "px";
			this.scrollArea.style.height = point.y + "px";
		};

		window.getPageSize = function() {
			return this.pageSize;
		};

		return window;

	};

}());
/**
 * @author richt / http://richt.me
 * @author WestLangley / http://github.com/WestLangley
 *
 * W3C Device Orientation control (http://w3c.github.io/deviceorientation/spec-source-orientation.html)
 */

THREE.DeviceOrientationControls = function ( object ) {

	var scope = this;

	this.object = object;
	this.object.rotation.reorder( "YXZ" );

	this.enabled = true;

	this.deviceOrientation = {};
	this.screenOrientation = 0;

	this.setCanvasSize = function(point) {

	};

	var onDeviceOrientationChangeEvent = function ( event ) {
		scope.deviceOrientation = event;
	};

	var onScreenOrientationChangeEvent = function () {
		scope.screenOrientation = window.orientation || 0;
	};

	// The angles alpha, beta and gamma form a set of intrinsic Tait-Bryan angles of type Z-X'-Y''

	var setObjectQuaternion = function () {

		var zee = new THREE.Vector3( 0, 0, 1 );

		var euler = new THREE.Euler();

		var q0 = new THREE.Quaternion();

		var q1 = new THREE.Quaternion( - Math.sqrt( 0.5 ), 0, 0, Math.sqrt( 0.5 ) ); // - PI/2 around the x-axis

		return function ( quaternion, alpha, beta, gamma, orient ) {

			euler.set( beta, alpha, - gamma, 'YXZ' );                       // 'ZXY' for the device, but 'YXZ' for us

			quaternion.setFromEuler( euler );                               // orient the device

			quaternion.multiply( q1 );                                      // camera looks out the back of the device, not the top

			quaternion.multiply( q0.setFromAxisAngle( zee, - orient ) );    // adjust for screen orientation

		}

	}();

	this.connect = function() {

		onScreenOrientationChangeEvent(); // run once on load

		window.addEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
		window.addEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );

		scope.enabled = true;

	};

	this.disconnect = function() {

		window.removeEventListener( 'orientationchange', onScreenOrientationChangeEvent, false );
		window.removeEventListener( 'deviceorientation', onDeviceOrientationChangeEvent, false );

		scope.enabled = false;

	};

	this.update = function () {

		if ( scope.enabled === false ) return;

		var alpha  = scope.deviceOrientation.alpha ? THREE.Math.degToRad( scope.deviceOrientation.alpha ) : 0; // Z
		var beta   = scope.deviceOrientation.beta  ? THREE.Math.degToRad( scope.deviceOrientation.beta  ) : 0; // X'
		var gamma  = scope.deviceOrientation.gamma ? THREE.Math.degToRad( scope.deviceOrientation.gamma ) : 0; // Y''
		var orient = scope.screenOrientation       ? THREE.Math.degToRad( scope.screenOrientation       ) : 0; // O

		setObjectQuaternion( scope.object.quaternion, alpha, beta, gamma, orient );

	};

	this.connect();

};

fp = this.fp || {};

(function () {

	fp.Background3D = function(canvas) {
		this.camera = new THREE.PerspectiveCamera( 70, 1440 / 780, 1, 3000 );
		this.camera.position.z = 0;

		this.cameraContainer = new THREE.Object3D();
		this.cameraContainer.add(this.camera);

		this.scene = new THREE.Scene();
		this.scene.add(this.cameraContainer);
		this.scene.add(new THREE.AmbientLight(0xffffff));

		this.renderer = new THREE.WebGLRenderer();
		this.canvas = this.renderer.domElement;

		this.projectImages = [];
		var projects = document.querySelectorAll(".project");
		for (var i = 0; i < projects.length; i++) {
			var projectImage = new fp.ProjectImage(this.renderer);
			this.projectImages.push(projectImage);
		}

		var vertShader = document.getElementById('vertex_shader').innerHTML;
		var fragShader = document.getElementById('fragment_shader').innerHTML;

		var attributes = {};

		this.uniforms = {
			t1a: {type: "t", value: this.projectImages[0].textures["30"].texture},
			t1b: { type: "t", value: this.projectImages[0].textures["30"].texture},
			t2a: {type: "t", value: this.projectImages[1].textures["30"].texture},
			t2b: { type: "t", value: this.projectImages[1].textures["30"].texture},
			blurMixRatio: {
				type: "f",
				value: 0
			},
			mixRatio: {
				type: "f",
				value: 0.5
			}
		};

		var material = new THREE.ShaderMaterial({
			uniforms: this.uniforms,
			attributes: attributes,
			vertexShader: vertShader,
			fragmentShader: fragShader
		});

		var geometry = new THREE.SphereGeometry(2000, 100, 50, Math.PI / 2);
		this.object = new THREE.Mesh( geometry, material );
		this.object.scale.x = -1;
		this.object.material.side = THREE.DoubleSide;
		this.object.position.set( 0, 0, 0 );
		this.scene.add(this.object );

		this.image1 = null;
		this.image2 = null;

		this.index = NaN;
		this.opacity = NaN;
		this.blur = 30;

		this.setIndex(0);
	};

	var p = fp.Background3D.prototype;

	p.update = function(canvas) {
		var blurStep = 30;
		//var divide = this.blur / blurStep;
		//var floor = Math.floor(divide);

		var baseImage = "0";
		var blurImage = "30";
		if (this.blur == blurStep) {
			baseImage = "30";
		}
		if (this.blur == 0) {
			blurImage = "0";
		}
		//var baseImage = (floor * blurStep).toString();
		//var blurImage = (Math.min((floor + 1) * blurStep, 30)).toString();

		this.uniforms.blurMixRatio.value = this.blur / blurStep;
		//this.uniforms.blurMixRatio.value = Math.round((divide - floor) * 100) / 100;

		var floorIndex = Math.floor(this.index);

		var projectImage1 = this.projectImages[floorIndex];
		this.uniforms.t1a.value = projectImage1.textures[baseImage].texture;
		this.uniforms.t1b.value = projectImage1.textures[blurImage].texture;
		var projectImage2 = this.projectImages[Math.min(floorIndex + 1, this.projectImages.length - 1)];
		this.uniforms.t2a.value = projectImage2.textures[baseImage].texture;
		this.uniforms.t2b.value = projectImage2.textures[blurImage].texture;

		this.uniforms.mixRatio.value = Math.round((this.index - floorIndex) * 100) / 100;

		this.controls.update();

		this.renderer.render( this.scene, this.camera );
		//this.composer.render();
	};

	p.setCanvasSize = function(point) {
		this.canvasSize = point;

		this.camera.aspect = point.x / point.y;
		this.camera.updateProjectionMatrix();

		this.renderer.setSize( point.x, point.y );

		if (!this.controls) {
			if (tsunami.utils.isMobile.any) {
				this.controls = new THREE.DeviceOrientationControls(this.camera);
			} else {
				this.controls = new fp.MouseControls(this.camera);
			}
		}

		if (this.controls.setCanvasSize) {
			this.controls.setCanvasSize(point);
		}

	};

	p.addBlur = function() {
		if (this.tween) {
		 this.tween.stop();
		}
		this.tween = new tsunami.TimeTween(0, 0.5, this, {blur:[this.blur, 30 - this.blur]}, null, tsunami.easing.Sine.easeOut);
		this.tween.start();
	};

	p.removeBlur = function() {
		if (this.tween) {
		this.tween.stop();
		}
		this.tween = new tsunami.TimeTween(0, 1, this, {blur:[this.blur, 0 - this.blur]}, null, tsunami.easing.Sine.easeInOut);
		this.tween.start();
	};

	p.getIndex = function() {
		return this.index;
	};

	p.setIndex = function(value) {
		if (isNaN(value)) {
			return;
		}

		this.index = value;
	};

}());

(function () {

	fp.ProjectImage = function(renderer) {
		this.textures = {};
		this.textures["30"] = new fp.Texture(renderer);
		this.textures["0"] = new fp.Texture(renderer);
		/*
		var i = 30;
		while (i >= 0) {
			var texture = new fp.Texture(renderer);
			this.textures[i.toString()] = texture;
			i -= 5;
		}
		*/
	};

	var p = fp.ProjectImage.prototype;

	p.load = function(path, index) {
		this.textures["30"].loadImage(path + "_30.jpg", 0, 0);
		this.textures["0"].loadImage(path + "_0.jpg", 100, 1);
		/*
		var time = index * 100;
		var i = 30;
		while (i >= 0) {
			var texture = this.textures[i.toString()];
			texture.loadImage(path + "_" + i.toString() + ".jpg", time, i);
			time += 10;
			i -= 5;
		}
		*/
	}

}());

(function () {

	fp.Texture = function(renderer) {
		this.renderer = renderer;
		this.image = new Image();
		this.texture = new THREE.Texture(this.image);
		this.texture.minFilter = THREE.LinearFilter;
		this.texture.magFilter = THREE.LinearFilter;
		this.upload = true;
	};

	var p = fp.Texture.prototype;

	p.loadImage = function(path, delay, index) {
		this.path = path;
		this.delay = delay;
		this.index = index;
		this.image.onload = this.imageLoadHandler.bind(this);
		this.image.src = this.path;
	};

	p.imageLoadHandler = function() {
		this.timeout = setTimeout(this.uploadTexture.bind(this), this.delay);
	};

	p.uploadTexture = function() {
		this.texture.dispose();
		/*
		if (this.index == 0) {
			this.renderer.uploadTexture(this.texture);
		} else {
			this.texture.needsUpdate = true;
		}
		*/
		//this.renderer.uploadTexture(this.texture);
		this.texture.needsUpdate = true;
	};

}());
fp = this.fp || {};

(function () {

	fp.RootBranch = function() {
		this.branches = [];
	};

	var p = fp.RootBranch.prototype;

	p.getBranch = function(id) {
		for (var i = 0; i < this.branches.length; i++) {
			var branch = this.branches[i];
			if (branch.id == id) {
				return branch;
			}
		}
	};

	p.getDefaultBranch = function() {
		return this.defaultBranch;
	};

	p.load = function() {
		window.main.createStage();

		this.branches.push(new fp.ProjectsBranch());
		this.defaultBranch = "projects";

		var info = document.querySelector("#info");
		info.defaultBranch = "about";
		this.branches.push(info);
	};

	p.show = function() {
		//console.log("RootBranch.show");
	};

	p.hide = function() {
		//console.log("RootBranch.hide");
	};

}());
fp = this.fp || {};

(function () {

	fp.IntroBranch = function() {
		this.id = "intro";
	};

	var p = fp.IntroBranch.prototype;
/*
	p.show = function() {
		//console.log("IntroBranch.show");
		main.scroller.scroll(main.scroller.pageXOffset, 0);
	};
*/
	p.show = function() {
		var parallel = new tsunami.Parallel();
		var task = new tsunami.Task();
		parallel.addTask(task);
		parallel.addTask(new tsunami.Method(this.parent.scrollToSection.bind(this.parent), [0, task]));
		return parallel;
	};


}());
fp = this.fp || {};

(function () {

	fp.ProjectsBranch = function() {
		this.construct();
	};

	var p = fp.ProjectsBranch.prototype = new tsunami.Branch();

	p.constructBranch = p.construct;

	p.construct = function() {
		this.constructBranch("projects");

		this.branches.push(new fp.IntroBranch());
		var projects = document.querySelectorAll(".project");
		for (var i = 0; i < projects.length; i++) {
			var project = projects[i];
			var branch = new fp.ProjectBranch(project.id);
			this.branches.push(branch);
		}

		this.stageResizeHandler = this.stageResize.bind(this);
		this.stageUpdateHandler = this.stageUpdate.bind(this);
		this.windowScrollHandler = this.windowScroll.bind(this);
		this.stickyTweenHandler = this.stickyTweenComplete.bind(this);
	};

	p.addScrollHandler = function() {
		clearTimeout(this.addScrollTimeout);
		main.scroller.removeEventListener("scroll", this.windowScrollHandler);
		main.scroller.addEventListener("scroll", this.windowScrollHandler);
	};

	p.removeScrollHandler = function() {
		clearTimeout(this.addScrollTimeout);
		main.scroller.removeEventListener("scroll", this.windowScrollHandler);
	};

	p.addUpdateHandler = function() {
		fp.stage.addEventListener("update", this.stageUpdateHandler);
	};

	p.removeUpdateHandler = function() {
		fp.stage.removeEventListener("update", this.stageUpdateHandler);
	};

	p.show = function() {
		fp.stage.addEventListener("resize", this.stageResizeHandler);
		this.addUpdateHandler();
		this.addScrollTimeout = setTimeout(this.addScrollHandler.bind(this), 200);

		this.scrollTimeout = setTimeout(this.stoppedScrolling.bind(this), 1000);

		this.stageResize();
	};

	p.stageResize = function() {
		this.scroll = main.titles.getScroll();
		this.scrollTarget = this.scroll;

		main.scroller.setPageSize(new tsunami.geom.Point(fp.stage.size.x, fp.stage.size.y + main.titles.maxScroll));
		main.scroller.scroll(main.scroller.pageYOffset, this.scroll);
	};

	p.stageUpdate = function() {
		//main.titles.calculateMaxScroll();

		if (!this.stickyTween) {
			this.scrollTarget = main.scroller.pageYOffset;
		} else {
			this.scrollTarget = this.scroll;
		}
		this.scrollTarget = Math.max(this.scrollTarget, 0);
		this.scrollTarget = Math.min(this.scrollTarget, main.titles.maxScroll);

		this.scroll += (this.scrollTarget - this.scroll) * 0.15;

		this.scrollFactor = this.scroll / main.titles.maxScroll;

		main.titles.setScroll(this.scroll);
		main.introTimeline.currentFrameTarget = Math.min(this.scrollTarget, main.introOverlayTween.duration);
	};

	p.windowScroll = function(event) {
		clearTimeout(this.scrollTimeout);

		if (this.stickyTween) {
			this.stickyTween.removeEventListener(tsunami.TimeTween.COMPLETE, this.stickyTweenHandler);
			this.stickyTween.stop();
			this.stickyTween = null;
			this.tweenCompleteTask.taskCompleted();
			this.tweenCompleteTask = null;
		}

		main.router.setLocation(main.router.path + main.router.fragment + "projects");

		this.scrollTimeout = setTimeout(this.stoppedScrolling.bind(this), 750);
	};

	p.stoppedScrolling = function() {

		var branchIndex = Math.round(main.titles.index + 1);

		if (main.titles.index > -1 && main.titles.index < 0.5) {
			branchIndex = 1;
		}

		if (!isNaN(branchIndex)) {
			var branch = this.branches[branchIndex];
			main.router.setLocation(main.router.path + main.router.fragment + "projects/" + branch.id, true);
		}

	};

	p.scrollToSection = function(newScroll, tweenCompleteTask) {
		clearTimeout(this.scrollTimeout);

		this.tweenCompleteTask = tweenCompleteTask;

		var currentScroll = this.scroll;
		var changeScroll = newScroll - currentScroll;

		this.removeScrollHandler();

		var diff = Math.abs(changeScroll) / main.titles.offsetHeight;

		this.stickyTween = new tsunami.TimeTween(0, diff + 0.33, this, {scroll:[currentScroll,changeScroll]}, null, tsunami.easing.Cubic.easeOut);
		this.stickyTween.addEventListener(tsunami.TimeTween.COMPLETE, this.stickyTweenHandler);
		this.stickyTween.start();

		this.addScrollTimeout = setTimeout(this.addScrollHandler.bind(this), 200);
	};

	p.stickyTweenComplete = function(event) {
		this.stickyTween.removeEventListener(tsunami.TimeTween.COMPLETE, this.stickyTweenHandler);
		this.removeScrollHandler();
		main.scroller.scroll(main.scroller.pageXOffset, this.scroll);
		setTimeout(this.stickyTweenCompleteAddScroll.bind(this), 200);
	};

	p.stickyTweenCompleteAddScroll = function() {
		this.stickyTween = null;
		this.addScrollTimeout = setTimeout(this.addScrollHandler.bind(this), 200);
		if (this.tweenCompleteTask) {
			this.tweenCompleteTask.taskCompleted();
		}
	};

	p.hide = function() {
		clearTimeout(this.scrollTimeout);
		fp.stage.removeEventListener("resize", this.stageResizeHandler);
		this.removeUpdateHandler();
		this.removeScrollHandler();
		main.scroller.setPageSize(new tsunami.geom.Point(fp.stage.size.x, 0));
	};

}());
fp = this.fp || {};

(function () {

	fp.ProjectBranch = function(id) {
		this.construct(id);
	};

	var p = fp.ProjectBranch.prototype = new tsunami.Branch();

	p.constructBranch = p.construct;

	p.construct = function(id) {
		this.constructBranch(id);

		var description = new fp.ProjectDescriptionBranch("description");
		this.branches.push(description);
		this.defaultBranch = description.id;

		var credits = new fp.ProjectDescriptionBranch("credits");
		this.branches.push(credits);
	};

	p.load = function() {
	};

	p.show = function() {
		var parallel = new tsunami.Parallel();
		var title = document.querySelector("#titles #" + this.id);
		var task = new tsunami.Task();
		parallel.addTask(task);
		parallel.addTask(new tsunami.Method(this.parent.scrollToSection.bind(this.parent), [title.scroll, task]));
		//parallel.addTask(new tsunami.Method(main.background.removeBlur.bind(main.background)));
		var series = new tsunami.Series();
		series.addTask(parallel);
		series.addTask(new tsunami.Method(this.scrollComplete.bind(this)));
		return series;
	};

	p.scrollComplete = function() {
		main.background.removeBlur();
		var selectedTitle = document.querySelector("#titles #" + this.id);
		selectedTitle.style.zIndex = 100;
		selectedTitle.select();
		var titles = document.querySelectorAll("#titles .project");
		for (var i = 0; i < titles.length; i++) {
			var title = titles.item(i);
			if (title != selectedTitle) {
				title.addClass("hidden");
			}
		}
	};

	p.hide = function() {
		main.background.addBlur();

		var selectedTitle = document.querySelector("#titles #" + this.id);
		selectedTitle.style.zIndex = 0;
		selectedTitle.deselect();
		var titles = document.querySelectorAll("#titles .project");
		for (var i = 0; i < titles.length; i++) {
			var title = titles.item(i);
			if (title != selectedTitle) {
				title.removeClass("hidden");
			}
		}
	};

}());
fp = this.fp || {};

(function () {

	fp.ProjectDescriptionBranch = function(id) {
		this.id = id;
	};

	var p = fp.ProjectDescriptionBranch.prototype;

	p.load = function() {
		//console.log("ProjectDescriptionBranch.load", this.id);
	};

	p.show = function() {
		var title = document.querySelector("#titles #" + this.parent.id);

		var button = title.querySelector(".projectNav ." + this.id);
		button.select();

		var section = title.querySelector(".projectInfo #" + this.id);
		section.show();
	};

	p.hide = function() {
		var title = document.querySelector("#titles #" + this.parent.id);

		var button = title.querySelector(".projectNav ." + this.id);
		button.deselect();

		var section = title.querySelector(".projectInfo #" + this.id);
		section.hide();
	};

}());

fp = this.fp || {};

fp.OverlayContent = function(p) {

	tsunami.BranchElement(p);

	p.construct = function() {
		this.overlayContent = tsunami.DisplayObject(this.querySelector(".overlayContent"));
		this.overlayContent.setOpacity(0);
		this.overlayContent.units.translateX = "%";
		this.overlayContent.units.translateY = "%";
	};

	p.load = function() {
		var menuItem = this.parent.querySelector("#menu #" + this.id);
		if (menuItem) {
			menuItem.addClass("selected");
		}
	};

	p.show = function() {
		var series = new tsunami.Series();
		series.addTask(new tsunami.Method(this.addClass.bind(this), ["visible"]));
		var tween = new tsunami.TimeTween(0, 0.5, this.overlayContent, null, {setTranslateZ:[0, -0], setOpacity:[0, 1], setTranslateY:[15, -15]}, tsunami.easing.Cubic.easeOut);
		tween.addEventListener(tsunami.TimeTween.CHANGE, this.overlayContent.updateTransform.bind(this.overlayContent));
		series.addTask(tween);
		return series;
	};

	p.hide = function() {
		var menuItem = this.parent.querySelector("#menu #" + this.id);
		if (menuItem) {
			menuItem.removeClass("selected");
		}
		var series = new tsunami.Series();
		var tween = new tsunami.TimeTween(0, 0.5, this.overlayContent, null, {setTranslateZ:[0, -0], setOpacity:[1, -1], setTranslateY:[0, -10]}, tsunami.easing.Cubic.easeIn);
		tween.addEventListener(tsunami.TimeTween.CHANGE, this.overlayContent.updateTransform.bind(this.overlayContent));
		series.addTask(tween);
		series.addTask(new tsunami.Method(this.removeClass.bind(this), ["visible"]));
		return series;
	};

	p.construct();

};



fp.OverlayContentText = function(p) {

	fp.OverlayContent(p);

	p.construct = function() {
		this.stageResizeHandler = this.stageResize.bind(this);
		this.stageUpdateHandler = this.stageUpdate.bind(this);
		this.contents = this.querySelector(".text");
	};

	p.showOverlayContent = p.show;

	p.show = function() {
		var series = this.showOverlayContent();
		series.addTaskAt(new tsunami.Method(this.addHandlers.bind(this)), 1);
		return series;
	};

	p.addHandlers = function() {
		this.scroll = 0;
		fp.stage.addEventListener("resize", this.stageResizeHandler);
		fp.stage.addEventListener("update", this.stageUpdateHandler);

		this.stageResize();

		main.scroller.scroll(0, 0);
	};

	p.stageResize = function() {
		//console.log("AboutBranch.stageResize");

		//console.log("scrollHeight", this.contents.scrollHeight, "clientHeight", this.contents.clientHeight);

		//this.contents.style.maxHeight = this.offsetHeight / 2 + "px";

		var maxScroll = this.contents.scrollHeight - this.contents.clientHeight;

		main.scroller.setPageSize(new tsunami.geom.Point(fp.stage.size.x, maxScroll + fp.stage.size.y));
		//main.scroller.scroll(main.scroller.pageXOffset, this.scroll * fp.stage.size.y);
	};

	p.stageUpdate = function() {
		this.scroll = main.scroller.pageYOffset;
		//this.scroll = Math.min(this.scroll, 1);
		//this.scroll = Math.max(this.scroll, 0);

		this.contents.scrollTop = this.scroll;
	};

	p.hideOverlayContent = p.hide;

	p.hide = function() {
		//console.log("OverlayContentText.hide", this.id);

		fp.stage.removeEventListener("resize", this.stageResizeHandler);
		fp.stage.removeEventListener("update", this.stageUpdateHandler);

		//var scrollArea = document.querySelector("#scrollArea");
		//scrollArea.style.height = 0 + "px";

		main.scroller.setPageSize(new tsunami.geom.Point(fp.stage.size.x, 0));

		return this.hideOverlayContent();
	};

	p.construct();

};



fp.Press = function(o) {

	fp.OverlayContentText(o);

	o.addHandlersOverlayContentText = o.addHandlers;

	o.addHandlers = function() {
		var msnry = new Masonry( this.querySelector(".list"), {
			itemSelector: 'div'
		});

		this.addHandlersOverlayContentText();
	};

	return o;

};

fp.Talent = function(o) {

	o.load = function() {
		var menuItem = this.parent.querySelector("#menu #" + this.id);
		if (menuItem) {
			menuItem.addClass("selected");
		}
	};

	o.hide = function() {
		var menuItem = this.parent.querySelector("#menu #" + this.id);
		if (menuItem) {
			menuItem.removeClass("selected");
		}
	};



	o.getBranch = function(id) {
		var view = this.querySelector("#" + id);
		if (!view) {
			view = this.querySelector("#job-description");
			view.jobID = id;
		}
		console.log("view", view);
		return view;
	};

};


fp.JobDescription = function(o) {

	fp.OverlayContentText(o);

	o.load = function() {
		console.log("this.jobID", this.jobID);
		this.xhr = new tsunami.XHR("jobs/" + this.jobID + ".json");
		return this.xhr;
	};

	o.showJobDescription = o.show;

	o.show = function() {
		var language = document.documentElement.getAttribute("lang");
		var model = JSON.parse(this.xhr.responseText)[language];
		this.querySelector(".title h1").innerHTML = model.title;
		this.querySelector(".description").innerHTML = model.text;
		this.querySelector(".apply.button").setAttribute("href", "mailto:arv004@gmail.com?subject=" + model.title);
		return this.showJobDescription();
	};

};


fp.Contact = function(p) {

	fp.OverlayContent(p);

	p.showOverlayContent = p.show;

	p.show = function() {
		if (!this.map) {
			this.map = document.querySelector("#map");
		}
		if (main.googleMap) {
			main.googleMap.setCenter(main.mapOptions.center);
		}
		this.overlayContent.appendChild(this.map);
		return this.showOverlayContent();
	};

};
fp = this.fp || {};

(function () {

	fp.OverlayBranch = function(p) {

		tsunami.BranchElement(p);
		tsunami.DisplayObject(p);

		p.construct = function() {
			this.setOpacity(0);
		};

		p.load = function() {
		};

		p.show = function() {
			document.body.addClass("hasOverlay");
			var series = new tsunami.Series();
			var parallel = new tsunami.Parallel();
			if (main.titles.getScroll() < main.titles.offsetHeight) {
				//main.titles.setScroll(main.titles.offsetHeight);
				main.introTimeline.currentFrameTarget = main.titles.offsetHeight;
				var scrollTween = new tsunami.TimeTween(0, 1, main.titles, null, {setScroll:[main.titles.getScroll(), main.titles.offsetHeight - main.titles.getScroll()]}, tsunami.easing.Linear.easeOut);
				scrollTween.start();
				//parallel.addTask(scrollTween);
			}
			parallel.addTask(new tsunami.Method(this.addClass.bind(this), ["visible"]));
			var tween = new tsunami.TimeTween(0, 0.5, this, null, {setOpacity:[0, 1]}, tsunami.easing.Cubic.easeOut);
			parallel.addTask(tween);
			series.addTask(parallel);

			var hamburger = document.querySelector("#hamburger");
			series.addTask(new tsunami.Method(hamburger.makeClose.bind(hamburger)));
			series.addTask(this.querySelector("#menu #cell").show());
			return series;

		};

		p.hide = function() {

			var series = new tsunami.Series();
			var hamburger = document.querySelector("#hamburger");
			series.addTask(new tsunami.Method(hamburger.makeHamburger.bind(hamburger)));
			series.addTask(this.querySelector("#menu #cell").hide());
			var tween = new tsunami.TimeTween(0, 0.5, this, null, {setTranslateZ:[0, -0], setOpacity:[1, -1]}, tsunami.easing.Cubic.easeOut);
			series.addTask(tween);
			series.addTask(new tsunami.Method(this.removeClass.bind(this), ["visible"]));
			series.addTask(new tsunami.Method(function(){document.body.removeClass("hasOverlay");}));
			return series;
		};

		p.getBranch = function(id) {
			return this.querySelector("#contents #" + id);
		};

		p.construct();

	};

}());
fp = this.fp || {};

(function () {

	fp.OverlayMenu = function(p) {

		p.construct = function() {
			this.menuItems = this.querySelector("#menuItems");
			this.menuItems.setOpacity(0);
			this.menuItems.units.translateX = "%";
			this.menuItems.units.translateY = "%";
		};

		p.load = function() {
		};

		p.show = function() {
			var series = new tsunami.Series();
			series.addTask(new tsunami.Method(this.addClass.bind(this), ["visible"]));
			var tween = new tsunami.TimeTween(0, 0.4, this.menuItems, null, {setTranslateZ:[0, -0], setOpacity:[0, 1], setTranslateY:[50, -50]}, tsunami.easing.Cubic.easeOut, this.menuItems.updateTransform.bind(this.menuItems));
			series.addTask(tween);
			return series;
		};

		p.hide = function() {
			var series = new tsunami.Series();
			var tween = new tsunami.TimeTween(0, 0.4, this.menuItems, null, {setTranslateZ:[0, -0], setOpacity:[1, -1], setTranslateY:[0, -50]}, tsunami.easing.Cubic.easeIn, this.menuItems.updateTransform.bind(this.menuItems));
			series.addTask(tween);
			series.addTask(new tsunami.Method(this.removeClass.bind(this), ["visible"]));
			return series;
		};

		p.construct();

	};

}());
fp = this.fp || {};


fp.ProjectTitles = function(o) {

	tsunami.DisplayObject(o);
	//tsunami.List(o);

	o.construct = function() {
		this.units.top = "%";
		this.units.marginTop = "rem";
		this.units.translateY = "%";

		this.projects = this.querySelectorAll(".project");
		for (var i = 0; i < this.projects.length; i++) {
			var project = this.projects[i];
			project.units.translateY = "px";
		}
/*
		this.maxProjects = 5;
		this.minIndex = this.maxProjects / -2;
		this.maxIndex = this.maxProjects / 2;
*/
		this.selectedScroll = 0;
		this._index = 0;
		this._menuScroll = 0;

		this.scrollFactor = 0;
		this.scroll = 0;
		this.maxScroll = 0;
	};

	o.calculateMaxScroll = function() {
		var maxScroll = this.offsetHeight * 1;
		var posY = maxScroll - this.projects.item(0).container.offsetHeight / 2;
		for (var k = 0; k < this.projects.length; k++) {
			var project = this.projects.item(k);
			project.posY = posY;
			var projectHalf = project.container.offsetHeight / 2;
			if (k > 0) {
				maxScroll += projectHalf;
			}
			project.scroll = maxScroll;
			if (k < this.projects.length - 1) {
				maxScroll += projectHalf;
			}
			posY += project.container.offsetHeight;
		}
		this.maxScroll = maxScroll;
		this.setScroll(this.scrollFactor * this.maxScroll);
	};

	o.getScroll = function() {
		return this.scroll;
	};

	o.setScroll = function(value) {
		this.scroll = value;
		this.scrollFactor = this.scroll / this.maxScroll;

		var start = this.projects.item(0).container.offsetHeight / 2;

		var height = this.offsetHeight;
		var halfHeight = height / 2;

		var index;
		for (var k = 0; k < this.projects.length; k++) {
			var project = this.projects.item(k);
			var projectHeight = project.container.offsetHeight;
			var projectHalfHeight = projectHeight / 2;

			var posY = project.posY - value;

			var offsetY = project.scroll - value;

			var scale;
			var translate = posY + halfHeight;
			var opacity;
			if (offsetY < 0) {
				offsetY = Math.max(offsetY, -halfHeight);
				var factor = offsetY / halfHeight;
				scale = tsunami.easing.Sine.easeInOut(-factor, 1, -1, 1);
				translate = tsunami.easing.Sine.easeOut(-factor, height / 2.5, -height / 2.5, 1);
				opacity = tsunami.easing.Sine.easeIn(-factor, 1, -1, 1);
			} else {
				offsetY = Math.min(offsetY, halfHeight);
				var factor = offsetY / halfHeight;
				scale = tsunami.easing.Sine.easeInOut(factor, 1, -1, 1);
				translate = tsunami.easing.Sine.easeOut(factor, height / 2.5, height - height / 2.5, 1);
				opacity = tsunami.easing.Sine.easeIn(factor, 1, -1, 1);
			}

			translate -= projectHalfHeight;
			translate = Math.round(translate * 10) / 10;

			var indexFactor = offsetY / projectHeight * -1;

			var min = -0.5;
			if (k == 0) {
				min = -halfHeight / projectHeight;
			}

			if (indexFactor > min && indexFactor < 0.5) {
				index = k + indexFactor;
				project.container.addClass("bold");
			} else {
				project.container.removeClass("bold");
			}

			project.setTranslateY(translate);
			project.setTranslateZ(0);
			project.setScale(scale);

			project.updateTransform();

			project.setOpacity(opacity);
		}
		if (!isNaN(index)) {
			this.index = Math.max(index, 0);
		} else {
			this.index = -1;
		}
		main.background.setIndex(Math.max(index, 0));
		main.sideMenu.setIndex(Math.round(index));
	};

	o.changeScroll = function(value) {
		if (this.scrollTween) {
			this.scrollTween.stop();
		}
		this.selectedScroll = value;
		var current = this.scrollIndex;
		var change = value - this.scrollIndex;
		this.scrollTween = new tsunami.Tween(0, 30, this, {scrollIndex:current}, {scrollIndex:change}, tsunami.easing.Cubic.easeOut);
		this.scrollTween.start();
	};

	o.construct();

	return o;
};


fp.ProjectTitle = function(o) {

	tsunami.DisplayObject(o);

	o.construct = function() {
		this.container = this.querySelector("#title");
		this.titleStyle = this.container.style;
		this.client = this.querySelector("#client");
		this.projectContent = this.querySelector(".projectContent");
		this.projectNav = this.querySelector(".projectNav");
		this.extra = this.querySelector("#extra");
		this.infos = [
			this.client,
			this.projectNav
		];
		if (this.extra) {
			this.infos.push(this.extra);
		}
		this.removeChild(this.client);
		this.removeChild(this.projectContent);
	};

	o.getModel = function() {
		return this.model;
	};

	o.setModel = function(value) {
		this.model = value;
	};

	o.select = function() {
		window.clearTimeout(this.timeoutID);
		this.appendChild(this.client);
		this.appendChild(this.projectContent);
		var delay = 0;
		for (var i = 0; i < this.infos.length; i++) {
			var info = this.infos[i];
			info.show(delay);
		}
	};

	o.deselect = function() {
		for (var i = 0; i < this.infos.length; i++) {
			var info = this.infos[i];
			info.hide();
		}
		this.timeoutID = window.setTimeout(this.removeChildren.bind(this), 1000);
	};

	o.removeChildren = function() {
		this.removeChild(this.client);
		this.removeChild(this.projectContent);
	};

	o.construct();

	return o;

};


fp.TitleInfo = function(o) {

	tsunami.DisplayObject(o);

	o.construct = function() {
		this.fadeCompleteHandler = this.fadeComplete.bind(this);
		this.units.translateY = "rem";
		this.setOpacity(0);
	};

	o.show = function(delay) {
		if (this.tween) {
			this.tween.stop();
		}
		if (isNaN(delay)) {
			delay = 0;
		}
		this.addClass("visible");
		this.tween = new tsunami.TimeTween(0.5, 1, this, null, {setOpacity:[0,1]}, tsunami.easing.Cubic.easeOut, this.updateTransform.bind(this));
		this.tween.start();
	};

	o.hide = function() {
		if (this.tween) {
			this.tween.stop();
		}
		this.tween = new tsunami.TimeTween(0, 0.5, this, null, {setOpacity:[this.getOpacity(),-this.getOpacity()]}, tsunami.easing.Cubic.easeOut, this.updateTransform.bind(this), this.fadeCompleteHandler);
		this.tween.start();
	};

	o.fadeComplete = function() {
		this.removeClass("visible");
	};

	o.construct();

	return o;

};


fp.ProjectNavButton = function(o) {

	fp.RouterButton(o);

	o.construct = function() {
		this.arrow = tsunami.DisplayObject(this.querySelector(".arrow"));
		this.arrow.units.translateY = "%";
	};

	o.select = function() {
		var tween = new tsunami.Tween(0, 15, this.arrow, null, {setOpacity:[0, 1], setTranslateZ:[0, 0], setTranslateY:[-200, 200]}, tsunami.easing.Cubic.easeOut, this.arrow.updateTransform.bind(this.arrow));
		tween.start();
	};

	o.deselect = function() {
		var tween = new tsunami.Tween(0, 15, this.arrow, null, {setOpacity:[1, -1], setTranslateZ:[0, 0], setTranslateY:[0, -200]}, tsunami.easing.Cubic.easeOut, this.arrow.updateTransform.bind(this.arrow));
		tween.start();
	};

	o.construct();

	return o;

};
fp = this.fp || {};

(function () {

	fp.ArrowDown = function(o) {

		o.construct = function() {

			this.lines = [];
			for (var i = 1; i < 3; i++) {
				var line = {};
				line.node = this.querySelector("#line" + i);
				line.y1 = eval(line.node.getAttribute("y1"));
				line.y2 = eval(line.node.getAttribute("y2"));
				this.lines.push(line);
			}

			this.offset = 0;

			this.tween1 = new tsunami.Tween(0, 40, this, null, {setOffset:[0, 8]}, tsunami.easing.Cubic.easeIn);
			this.tween1.name = "tween1";
			this.tween2 = new tsunami.Tween(0, 40, this, null, {setOffset:[8, -8]}, tsunami.easing.Cubic.easeOut);

			this.tween1.addEventListener(tsunami.Tween.COMPLETE, this.tween2.start.bind(this.tween2));
			this.tween2.addEventListener(tsunami.Tween.COMPLETE, this.tween1.start.bind(this.tween1));

			this.tween1.start();
		};

		o.setOffset = function(value) {
			for (var i = 0; i < this.lines.length; i++) {
				var line = this.lines[i];
				line.node.setAttribute("y1", line.y1 + value);
				line.node.setAttribute("y2", line.y2 + value);
			}
		};

		o.construct();

		return o;
	};

}());
fp.SideMenu = function(o) {

	o.construct = function() {
		this.projects = this.querySelectorAll(".sideProject");
		this.index = -1;
		this.selectedProject = null;
	};

	o.setIndex = function(value) {
		if (value != this.index) {
			if (isNaN(value) && !isNaN(this.index)) {
				this.removeClass("visible");
				main.social.removeClass("visible");
				this.index = -1;
			} else if (isNaN(this.index) && !isNaN(value)) {
				this.addClass("visible");
				main.social.addClass("visible");
			}
			if (this.selectedProject) {
				this.selectedProject.removeClass("selected");
			}
			this.index = value;
			if (this.index > -1) {
				this.selectedProject = this.projects.item(this.index);
				this.selectedProject.addClass("selected");
			}
		}
	};

	o.construct();

};

fp = this.fp || {};

fp.Hamburger = function(o) {

	fp.RouterButton(o);

	o.construct = function() {
		this.top = this.querySelector("#top");
		this.middle = this.querySelector("#middle");
		this.bottom = this.querySelector("#bottom");
	};

	o.makeClose = function() {
		var parallel = new tsunami.Parallel();

		var topTask = new tsunami.Parallel();
		topTask.addTask(new tsunami.Tween(0, 30, this.top.binder.x1, null, {setValue:[0, 9]}, tsunami.easing.Cubic.easeOut));
		topTask.addTask(new tsunami.Tween(0, 30, this.top.binder.y1, null, {setValue:[4, 6]}, tsunami.easing.Cubic.easeOut));
		topTask.addTask(new tsunami.Tween(0, 30, this.top.binder.x2, null, {setValue:[32, -9]}, tsunami.easing.Cubic.easeOut));
		topTask.addTask(new tsunami.Tween(0, 30, this.top.binder.y2, null, {setValue:[4, 19]}, tsunami.easing.Cubic.easeOut));
		parallel.addTask(topTask);

		var bottomTask = new tsunami.Parallel();
		bottomTask.addTask(new tsunami.Tween(0, 30, this.bottom.binder.x1, null, {setValue:[0, 9]}, tsunami.easing.Cubic.easeOut));
		bottomTask.addTask(new tsunami.Tween(0, 30, this.bottom.binder.y1, null, {setValue:[28, -5]}, tsunami.easing.Cubic.easeOut));
		bottomTask.addTask(new tsunami.Tween(0, 30, this.bottom.binder.x2, null, {setValue:[32, -9]}, tsunami.easing.Cubic.easeOut));
		bottomTask.addTask(new tsunami.Tween(0, 30, this.bottom.binder.y2, null, {setValue:[28, -18]}, tsunami.easing.Cubic.easeOut));
		//bottomTask.delay = 0.125;
		parallel.addTask(bottomTask);

		parallel.addTask(new tsunami.Tween(0, 30, this.middle, null, {setScale:[0, 1]}, tsunami.easing.Cubic.easeOut));

		parallel.start();

		this.href = "?projects";
	};

	o.makeHamburger = function() {
		var parallel = new tsunami.Parallel();

		var topTask = new tsunami.Parallel();
		topTask.addTask(new tsunami.Tween(0, 30, this.top.binder.x1, null, {setValue:[9, -9]}, tsunami.easing.Cubic.easeOut));
		topTask.addTask(new tsunami.Tween(0, 30, this.top.binder.y1, null, {setValue:[10, -6]}, tsunami.easing.Cubic.easeOut));
		topTask.addTask(new tsunami.Tween(0, 30, this.top.binder.x2, null, {setValue:[23, 9]}, tsunami.easing.Cubic.easeOut));
		topTask.addTask(new tsunami.Tween(0, 30, this.top.binder.y2, null, {setValue:[23, -19]}, tsunami.easing.Cubic.easeOut));
		//topTask.delay = 0.125;
		parallel.addTask(topTask);

		var bottomTask = new tsunami.Parallel();
		bottomTask.addTask(new tsunami.Tween(0, 30, this.bottom.binder.x1, null, {setValue:[9, -9]}, tsunami.easing.Cubic.easeOut));
		bottomTask.addTask(new tsunami.Tween(0, 30, this.bottom.binder.y1, null, {setValue:[23, 5]}, tsunami.easing.Cubic.easeOut));
		bottomTask.addTask(new tsunami.Tween(0, 30, this.bottom.binder.x2, null, {setValue:[23, 9]}, tsunami.easing.Cubic.easeOut));
		bottomTask.addTask(new tsunami.Tween(0, 30, this.bottom.binder.y2, null, {setValue:[10, 18]}, tsunami.easing.Cubic.easeOut));
		parallel.addTask(bottomTask);

		parallel.addTask(new tsunami.Tween(0, 30, this.middle, null, {setScale:[1, -1]}, tsunami.easing.Cubic.easeOut));

		parallel.start();

		this.href = "?info";
	};

	o.construct();

	return o;

};

fp.HamburgerLine = function(o) {

	o.binder = {};
	o.binder.x1 = new tsunami.Attribute(o, "x1", null, null);
	o.binder.y1 = new tsunami.Attribute(o, "y1", null, null);
	o.binder.x2 = new tsunami.Attribute(o, "x2", null, null);
	o.binder.y2 = new tsunami.Attribute(o, "y2", null, null);

};

fp.HamburgerCircle = function(o) {

	o.construct = function() {
		this.offsetY = 16;

		this.pathPts = [];

		var arc = Math.PI * 2;
		var radius = 16;
		var a1 = 0;
		var a2;
		var n = Math.floor(arc/(Math.PI/4)) + 1;
		var span = arc/(2*n);
		var spanCos = Math.cos(span);
		var rc = (spanCos) ? radius/spanCos : 0;
		var i;
		var centerPt = new tsunami.geom.Point(radius, 0);
		var startPt = new tsunami.geom.Point(radius, 0).add(centerPt);
		for (i = 0; i < n; i++) {
			a2 = a1 + span;
			a1 = a2 + span;
			var controlPt = new tsunami.geom.Point(Math.cos(a2)*rc, Math.sin(a2)*rc).add(centerPt);
			var endPt = new tsunami.geom.Point(Math.cos(a1)*radius, Math.sin(a1)*radius).add(centerPt);
			this.pathPts.push({startPt:startPt, controlPt:controlPt, endPt:endPt});

			startPt = endPt;
		}

		this.setScale(0);
	};

	o.getScale = function(value) {
		return this._scale;
	};

	o.setScale = function(value) {
		this._scale = value;
		var paths = this.querySelectorAll("path");
		for (var i = 0; i < this.pathPts.length; i++) {
			var pts = this.pathPts[i];
			var path = paths.item(i);
			var d = "M" + pts.startPt.x + " " + (pts.startPt.y * value + this.offsetY);
			d += " Q " + pts.controlPt.x + " " + (pts.controlPt.y * value + this.offsetY);
			d += " " + pts.endPt.x + " " + (pts.endPt.y * value + this.offsetY);
			path.setAttribute("d", d);
		}
	};

	o.construct();

};
fp = this.fp || {};

(function () {

	fp.LanguageMenu = function(o) {

		o.construct = function() {
			this.mouseUpHandler = this.buttonRelease.bind(this);
			this.querySelector(".button").addEventListener(tsunami.events.mouseup, this.mouseUpHandler);
		};

		o.buttonRelease = function(event) {
			if (this.hasClass("opened")) {
				this.closeMenu();
			} else {
				this.openMenu();
			}
		};

		o.openMenu = function() {
			if (this.tween) {
				this.tween.stop();
			}
			this.addClass("opened");
			var list = this.querySelector(".list");
			list.units.translateY = "%";
			this.tween = new tsunami.Tween(0, 30, list, null, {setTranslateY:[-98, 98]}, tsunami.easing.Cubic.easeOut, list.updateTransform.bind(list), this.openComplete.bind(this));
			this.tween.start();
			this.querySelector(".button").removeEventListener(tsunami.events.mouseup, this.mouseUpHandler);
		};

		o.openComplete = function() {
			document.body.addEventListener(tsunami.events.mouseup, this.mouseUpHandler);
		};

		o.closeMenu = function() {
			document.body.removeEventListener(tsunami.events.mouseup, this.mouseUpHandler);
			if (this.tween) {
				this.tween.stop();
			}
			var list = this.querySelector(".list");
			this.tween = new tsunami.Tween(0, 30, list, null, {setTranslateY:[0, -98]}, tsunami.easing.Cubic.easeOut, list.updateTransform.bind(list), this.closeComplete.bind(this));
			this.tween.start();
		};

		o.closeComplete = function() {
			this.removeClass("opened");
			this.querySelector(".button").addEventListener(tsunami.events.mouseup, this.mouseUpHandler);
		};

		o.construct();

		return o;
	};

}());
fp = this.fp || {};

(function () {

	fp.Main = function() {
	};

	var p = fp.Main.prototype;

	p.init = function() {

		this.router = new tsunami.Router();
		/*
		 this.router.addEventListener("complete", function() {
		 console.log("router complete", main.router.getLocation())
		 });
		 */

		/*
		Mustache.escape = function(string) {
			return string;
		};

		tsunami.utils.mustacheRender = function(text, scope) {
			return Mustache.render(text, scope);
		};
		*/
		tsunami.utils.applyWrapperAttribute(document.body, "wrapper");

		this.router.root = new fp.RootBranch();
		this.router.path = location.origin + location.pathname;
		this.router.fragment = "?";
		this.router.setHistory(tsunami.history);
		tsunami.history.fallback = tsunami.HistoryFallback.HASH;
		tsunami.history.start(this.router.path, this.router.fragment);
	};

	p.createStage = function() {
		fp.stage = new tsunami.EventDispatcher();
		fp.stage.size = tsunami.utils.getWindowRect().getSize();

		if (tsunami.utils.isMobile.any) {
			document.body.className = "isMobile";
			this.scroller = fp.ScrollerMobile();
		} else {
			this.scroller = fp.ScrollerDesktop(document.querySelector("#scrollArea"));
		}

		this.imageSizes = [
			{
				name:"240",
				size:new tsunami.geom.Point(0, 240),
				path:"img/640/"
			},
			{
				name:"320",
				size:new tsunami.geom.Point(0, 320),
				path:"img/640/"
			},
			{
				name:"480",
				size:new tsunami.geom.Point(0, 480),
				path:"img/960/"
			},
			{
				name:"640",
				size:new tsunami.geom.Point(0, 640),
				path:"img/1280/"
			},
			{
				name:"800",
				size:new tsunami.geom.Point(0, 800),
				path:"img/1600/"
			},
			{
				name:"960",
				size:new tsunami.geom.Point(0, 960),
				path:"img/1920/"
			},
			{
				name:"1120",
				size:new tsunami.geom.Point(0, 1120),
				path:"img/2240/"
			},
			{
				name:"1280",
				size:new tsunami.geom.Point(0, 1280),
				path:"img/2560/"
			}
		];


		//var template = document.querySelector("#siteTemplate").text;
		//tsunami.utils.createElement(template, document.body, "wrapper", window.model);

		this.stage = document.querySelector("#stage");
		this.stage.style.width = fp.stage.size.x + "px";
		this.stage.style.height = fp.stage.size.y + "px";

		this.bg = this.stage.querySelector("#bg");
		this.sideMenu = document.querySelector("#sideMenu");
		this.projectDescription = this.stage.querySelector("#projectDescription");
		this.contact = this.stage.querySelector("#contact");
		this.about = this.stage.querySelector("#about");
		this.introOverlay = this.stage.querySelector("#introOverlay");
		this.social = this.stage.querySelector(".social");
		this.background = new fp.Background3D();
		this.bg.appendChild(this.background.canvas);

		this.introTimeline = new tsunami.Timeline();
		this.introTimeline.updateEase = 0.25;

		this.removeIntroOverlay = new tsunami.TimelineAction(function() {
			//if (main.stage.contains(main.introText)) {
				main.introText.style.visibility = "hidden";
				main.cinematic.style.visibility = "hidden";
			//}
		}, 0, tsunami.TimelineAction.FORWARDS);

		this.addBackIntroOverlay = new tsunami.TimelineAction(function() {
			main.introText.style.visibility = "visible";
			main.cinematic.style.visibility = "visible";
		}, 0, tsunami.TimelineAction.BACKWARDS);

		this.introOverlayTween = new tsunami.Tween(0, 0, this.introOverlay.style, {opacity: [0.6, -0.6]}, null, tsunami.easing.Linear.easeOut);

		this.logo = document.querySelector("#logo");
		this.logo.units.top = "%";
		this.logo.units.translateY = "rem";
		this.logoTween = new tsunami.Tween(0, 0, this.logo, null, {setTop:[50, -50], setTranslateZ:[0, 0], setScale:[1, -0.6], setTranslateY:[-16, 9]}, tsunami.easing.Linear.easeOut);
		this.logoTween.addEventListener(tsunami.Tween.CHANGE, this.logo.updateTransform.bind(this.logo));

		//this.logoStudios = document.querySelector("#logoStudios");
		//this.logoStudiosTween = new tsunami.Tween(0, 0, this.logoStudios, null, {setOpacity:[0, 1]}, tsunami.easing.Linear.easeOut);

		this.cinematic = document.querySelector("#cinematic");
		this.cinematic.units.top = "%";
		this.cinematic.units.translateY = "rem";
		this.cinematicTween = new tsunami.Tween(0, 0, this.cinematic, null, {setTop:[50, -20], setTranslateZ:[0, 0], setScale:[1, -0.6], setOpacity:[1,-1], setTranslateY:[11, 0]}, tsunami.easing.Linear.easeOut);
		this.cinematicTween.addEventListener(tsunami.Tween.CHANGE, this.cinematic.updateTransform.bind(this.cinematic));

		var firstProject = document.querySelectorAll(".project").item(0);
		document.querySelector("#introTextButton").href = "?projects/" + firstProject.id;
		this.introText = document.querySelector("#introText");
		this.introText.units.top = "%";
		this.introText.units.translateY = "rem";
		this.introTextTween = new tsunami.Tween(0, 0, this.introText, null, {setTop:[100, -45], setTranslateZ:[0, 0], setScale:[1, -0.5], setOpacity:[1,-1], setTranslateY:[-10, 0]}, tsunami.easing.Linear.easeOut);
		this.introTextTween.addEventListener(tsunami.Tween.CHANGE, this.introText.updateTransform.bind(this.introText));

		this.titles = document.querySelector("#titles");


		window.resizeHandler = this.windowResizeHandler.bind(this);
		this.resizeStage();


		this.introTimeline.addAction(this.addBackIntroOverlay);
		this.introTimeline.addAction(this.removeIntroOverlay);

		this.introTimeline.addTween(this.introOverlayTween);
		this.introTimeline.addTween(this.logoTween);
		//this.introTimeline.addTween(this.logoStudiosTween);
		this.introTimeline.addTween(this.cinematicTween);
		this.introTimeline.addTween(this.introTextTween);

		this.animationFrame = new tsunami.AnimationFrame(false);
		this.animationFrame.addEventListener(tsunami.AnimationFrame.FRAME, this.animationFrameHandler.bind(this));
		//this.animationFrame.addEventListener(tsunami.AnimationFrame.FPS, this.animationFPSHandler.bind(this));
		//this.animationFrame();

		this.titles.calculateMaxScroll();
		this.titles.addClass("init");
	};

	p.createMap = function() {
		this.mapOptions = {
			center: { lat: 45.501495, lng: -73.556925},
			zoom:18,
			scrollwheel: true,
			navigationControl: true,
			mapTypeControl: !tsunami.utils.isMobile.any,
			scaleControl: true,
			draggable: !tsunami.utils.isMobile.any
		};

		if (google.maps.Map) {
			this.googleMap = new google.maps.Map(document.querySelector('#map'), this.mapOptions);
			var markerObj = {
				map: this.googleMap,
				position: this.mapOptions.center
			};
			new google.maps.Marker(markerObj);
		}
	};

	p.windowResizeHandler = function(event) {
		//if (tsunami.utils.isMobile.any) {
			//window.scroll(window.pageXOffset, 0);
		//}
	};

	p.resizeStage = function() {
		this.stage.style.width = fp.stage.size.x + "px";
		this.stage.style.height = fp.stage.size.y + "px";

		var titlesHeight = this.titles.offsetHeight;

		this.removeIntroOverlay.position = titlesHeight;
		this.addBackIntroOverlay.position = titlesHeight - 1;

		this.introOverlayTween.duration = titlesHeight;
		this.logoTween.duration = titlesHeight;
		//this.logoStudiosTween.startFrame = titlesHeight / 2;
		//this.logoStudiosTween.duration = titlesHeight / 2;
		this.cinematicTween.duration = titlesHeight / 1.5;
		this.introTextTween.duration = titlesHeight / 1.5;


		/* reload images */

		var currentImageSize;
		var currentDiff = Infinity;
		for (var i = 0; i < this.imageSizes.length; i++) {
			var imageSize = this.imageSizes[i];
			var diff = Math.abs(fp.stage.size.y - imageSize.size.y);
			if (diff < currentDiff) {
				currentImageSize = imageSize;
				currentDiff = diff;
			}
		}
		if (!currentImageSize) {
			currentImageSize = this.imageSizes[this.imageSizes.length - 1];
		}

		if (fp.imageSize != currentImageSize) {
			fp.imageSize = currentImageSize;
			var projects = document.querySelectorAll(".project");
			for (var i = 0; i < projects.length; i++) {
				var project = projects[i];
				var texture = this.background.projectImages[i];
				texture.load(fp.imageSize.path + project.id, i);
			}
		}

		this.background.setCanvasSize(fp.stage.size);
		this.titles.calculateMaxScroll();

		fp.stage.dispatchEvent({type:"resize"});
	};

	p.animationFrameHandler = function() {
		var windowSize = tsunami.utils.getWindowRect().getSize();
		if (!fp.stage.size.equals(windowSize)) {
			fp.stage.size = windowSize;
			this.resizeStage();
		}

		fp.stage.dispatchEvent({type:"update"});

		this.introTimeline.update();

		this.background.update();

		tsunami.Tween.clock.tick();
		tsunami.TimeTween.clock.tick();
	};

	p.animationFPSHandler = function(event) {
		this.stats.innerHTML = event.frames + " / " + event.averageFrames;
	};

}());


fp.RouterButton = function(o) {

	tsunami.RouterButton(o);

	o.router = main.router;
	o.pushState = true;

	return o;

};

